{"posts":[{"title":"JUnit 4とJUnit 5の違い","text":"現在のプロジェクトでは、いくつかの古いプロジェクトがJUnit 4を使用していますが、新しいプロジェクトでは一般的にJUnit 5とMockitoが使用されています。本記事では、JUnit 4とJUnit 5の違いを記録します。 JUnit 5 は JUnit 4 の進化版で、数多くの改善が加えられています。主な違いは以下の通りです。 1. アーキテクチャの違い 比較項目 JUnit 4 JUnit 5 コアアーキテクチャ モノリシックアーキテクチャ（すべての機能は junit-4.x.jar に含まれている） モジュール化されたアーキテクチャ（junit-jupiter、junit-platform、junit-vintage など） 拡張性 Runner（例： @RunWith）に依存 Extension 機構を提供し、拡張がより柔軟 Java バージョン Java 5 以上に対応 Java 8 以上が必要 JUnit 5 は以下の 3 つの部分で構成されています JUnit Platform：異なるテストフレームワーク（JUnit、TestNG など）をサポートし、IDE や CI/CD 内でテストを実行できます。 JUnit Jupiter：JUnit 5 のコア API で、新しい機能（例：@TestFactory）を提供します。 JUnit Vintage：JUnit 4 と 3 をサポートし、古いプロジェクトの移行を容易にします。 2. アノテーションの違い 機能 JUnit 4 JUnit 5 テストメソッド @Test @Test テスト前の初期化 @Before @BeforeEach テスト後のクリーンアップ @After @AfterEach すべてのテスト前の実行 @BeforeClass（static） @BeforeAll（static または @TestInstance(Lifecycle.PER_CLASS)） すべてのテスト後の実行 @AfterClass（static） @AfterAll（static または @TestInstance(Lifecycle.PER_CLASS)） テストを無視する @Ignore @Disabled パラメータ化テスト @RunWith(Parameterized.class) が必要 @ParameterizedTest、より簡潔 3. アサーション（Assertions） JUnit 5 は org.junit.jupiter.api.Assertions において、より豊富なアサーションを提供します。例えば： 12345678import static org.junit.jupiter.api.Assertions.*;@Testvoid testAssertions() { assertEquals(2, 1 + 1, &quot;計算エラー&quot;); assertTrue(&quot;hello&quot;.startsWith(&quot;h&quot;), &quot;開始文字エラー&quot;); assertThrows(ArithmeticException.class, () -&gt; 1 / 0, &quot;例外が発生すべき&quot;);} JUnit 4 に比べ、JUnit 5 ではアサーションの組み合わせが可能になり、可読性が向上しました： 12345assertAll(&quot;Math tests&quot;, // &quot;Math tests&quot;という名前を付け、テスト失敗時に表示される情報を提供 () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(4 &gt; 3), () -&gt; assertNotNull(new Object())); ラムダ式 JUnit 5 は ラムダ式をアサーションに使用し、すべてのアサーションが実行されるため、1つのアサーションが失敗しても、後続のアサーションが実行されます。 これは JUnit 4 の従来の書き方に比べ、柔軟性があり、複数のテスト条件が確実にチェックされます。 これらのアサーションが個別に実行されると、最初に失敗したテストでテストが終了します。しかし、assertAll を使用すると、テストはすべての失敗したアサーションを出力します。例えば： 1234org.opentest4j.MultipleFailuresError: Math tests (3 failures)1) 期待値: &lt;3&gt; だが、実際は: &lt;2&gt;2) 期待値: &lt;true&gt; だが、実際は: &lt;false&gt;3) 期待値: null ではない これにより、開発者は一度に複数のエラーを確認でき、1つを修正して再度テストを実行する必要がなくなります。 4. 動的テスト JUnit 5 は @TestFactory を導入し、テストケースを動的に作成できます： 123456@TestFactoryStream&lt;DynamicTest&gt; dynamicTests() { return Stream.of(1, 2, 3).map(n -&gt; DynamicTest.dynamicTest(&quot;テスト: &quot; + n, () -&gt; assertTrue(n &gt; 0)) );} JUnit 4 にはこのような機能はありません。 5. 拡張機構 JUnit 4 は @RunWith 拡張（例：@RunWith(SpringRunner.class)）を使用しますが、1つのテストクラスで1つの @RunWith のみを使用できます： 123@RunWith(SpringRunner.class)public class MyTest {} JUnit 5 は @ExtendWith に置き換わり、複数の拡張をサポートします： 1234@ExtendWith(SpringExtension.class)@ExtendWith(MyCustomExtension.class)public class MyTest {} 6. Spring Boot サポート Spring Boot 2.4+ はデフォルトで JUnit 5（JUnit Jupiter）をサポートします。 JUnit 4 を引き続き使用している場合、junit-vintage-engine の互換ライブラリを追加する必要があります。 7. 移行方法 JUnit 4 から JUnit 5 に移行するには： Maven/Gradle の依存関係を変更 12345678910111213&lt;!-- JUnit 4 を削除 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- JUnit 5 を追加 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; アノテーションを更新（例：@Before → @BeforeEach）。 @ExtendWith を使用して @RunWith を置き換え。 8. まとめ 比較項目 JUnit 4 JUnit 5 モジュール化 単一 JAR 複数のモジュール（Jupiter、Platform、Vintage） Java バージョン Java 5 以上 Java 8 以上 拡張機構 @RunWith（単一） @ExtendWith（複数可） テストライフサイクル @Before / @After @BeforeEach / @AfterEach 動的テスト ❌ ✅ @TestFactory パラメータ化テスト 複雑（@RunWith(Parameterized.class)） シンプル（@ParameterizedTest） Spring サポート @RunWith(SpringRunner.class) @ExtendWith(SpringExtension.class) 新しいプロジェクトには、直接 JUnit 5 を使用することをお勧めします。古いプロジェクトでは、JUnit Vintage を使用して JUnit 4 のコードを互換させ、徐々に JUnit 5 に移行することができます。","link":"/The-difference-between-JUnit-4-and-JUnit-5/"},{"title":"Javaプロジェクトにおける前後端データの交換方法","text":"この記事では、Javaプロジェクトにおけるフロントエンドとバックエンドのデータ交換方法について論じています。具体的には、さまざまな一般的な技術とシーンが取り上げられています。 Javaプロジェクトにおけるフロントエンドとバックエンドのデータ交換方法には主に以下の種類があり、具体的にどれを選択するかはプロジェクトのアーキテクチャ（Spring Boot、Spring MVC、JSP など）やフロントエンド技術（Vue、React、Thymeleaf など）に依存します。 一般的なケース 1. JSONを使用したデータ交換（フロントエンドとバックエンドが分離されている、REST APIでよく使用される） 適用シーン：Spring Boot + Vue/React/フロントエンドフレームワーク フロントエンド（JavaScriptでFetchを使ってリクエストを送信） 12345678fetch(&quot;http://localhost:8080/api/user&quot;, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot; }, body: JSON.stringify({ username: &quot;ゴ&quot;, age: 25 })}).then(response =&gt; response.json()).then(data =&gt; console.log(&quot;返されたデータ:&quot;, data)).catch(error =&gt; console.error(&quot;リクエスト失敗:&quot;, error)); バックエンド（Spring BootでJSONリクエストとレスポンスを処理） 123456789101112@RestController@RequestMapping(&quot;/api&quot;)public class UserController { @PostMapping(&quot;/user&quot;) public Map&lt;String, Object&gt; createUser(@RequestBody User user) { Map&lt;String, Object&gt; response = new HashMap&lt;&gt;(); response.put(&quot;message&quot;, &quot;ユーザー &quot; + user.getUsername() + &quot; の作成に成功しました&quot;); response.put(&quot;status&quot;, &quot;success&quot;); return response; // JSON形式でデータを返します }} 2. URLでデータを渡す（GETリクエスト） 適用シーン：データを検索する場合、例えば検索機能 フロントエンド（JavaScriptでGETリクエストを送信） 123fetch(&quot;http://localhost:8080/api/user?name=吴&quot;) .then(response =&gt; response.json()) .then(data =&gt; console.log(&quot;返されたデータ:&quot;, data)); バックエンド（Spring BootでURLパラメータを解析） 1234@GetMapping(&quot;/user&quot;)public User getUser(@RequestParam String name) { return new User(name, 25); // ユーザーオブジェクトを返すと仮定} 3. フォームを使用したデータ送信（従来のWeb開発） 適用シーン：Spring MVC + JSP / Thymeleaf フロントエンド（HTMLフォームでデータを送信） 1234&lt;form action=&quot;/submit&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;ユーザー名を入力&quot;&gt; &lt;button type=&quot;submit&quot;&gt;送信&lt;/button&gt;&lt;/form&gt; バックエンド（Spring MVCでフォームデータを解析） 12345@PostMapping(&quot;/submit&quot;)public String handleForm(@RequestParam String username) { System.out.println(&quot;ユーザー名を受け取りました：&quot; + username); return &quot;success&quot;; // ビューを返す} 4. セッションを使用してデータを渡す（ユーザーのログイン状態） 適用シーン：ユーザーセッション情報の保存 バックエンド（Spring Bootでセッションデータを設定） 12345@PostMapping(&quot;/login&quot;)public String login(HttpSession session, @RequestParam String username) { session.setAttribute(&quot;user&quot;, username); return &quot;ログイン成功&quot;;} バックエンド（セッションデータを取得） 1234@GetMapping(&quot;/profile&quot;)public String getUser(HttpSession session) { return &quot;現在のユーザー：&quot; + session.getAttribute(&quot;user&quot;);} 5. WebSocketを使用したリアルタイム通信（例：チャットシステム） 適用シーン：リアルタイムデータのプッシュ、例えばWebチャットや株価の更新 バックエンド（Spring WebSocketでメッセージを処理） 12345@MessageMapping(&quot;/chat&quot;)@SendTo(&quot;/topic/messages&quot;)public String sendMessage(String message) { return &quot;受信：&quot; + message;} フロントエンド（JavaScript WebSocket接続） 12let socket = new WebSocket(&quot;ws://localhost:8080/chat&quot;);socket.onmessage = (event) =&gt; console.log(&quot;メッセージを受信:&quot;, event.data); まとめ 方法 適用シーン 例 JSON (REST API) フロントエンドとバックエンドが分離（Vue/React） @RequestBody でJSONを解析 URLパラメータ データの検索 @RequestParam でパラメータを解析 フォーム送信 従来のWeb開発 @RequestParam でフォームデータを解析 セッション ログイン状態 session.setAttribute でデータを渡す WebSocket リアルタイム通信 WebSocket でメッセージをプッシュ Ajax Ajax（非同期JavaScriptおよびXML）は、ページを再読み込みすることなくフロントエンドがバックエンドと通信できる技術です。JavaプロジェクトにおけるAjaxの使用は、フロントエンド（JSがリクエストを送信）＋ バックエンド（Javaがリクエストを処理してデータを返す） という構成になります。 1. AjaxでGETリクエストを送信（データを検索） 適用シーン：ユーザー情報の検索や検索機能など。 フロントエンド（HTML + JavaScript） 12345678910111213&lt;button onclick=&quot;getUser()&quot;&gt;ユーザー情報を取得&lt;/button&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt;function getUser() { fetch(&quot;http://localhost:8080/api/user?name=吴&quot;) // GETリクエストを送信 .then(response =&gt; response.json()) // JSONを解析 .then(data =&gt; { document.getElementById(&quot;result&quot;).innerText = &quot;ユーザー名：&quot; + data.username; }) .catch(error =&gt; console.error(&quot;リクエストエラー:&quot;, error));}&lt;/script&gt; バックエンド（Spring Bootでリクエストを処理） 123456789@RestController@RequestMapping(&quot;/api&quot;)public class UserController { @GetMapping(&quot;/user&quot;) public User getUser(@RequestParam String name) { return new User(name, 25); // ユーザーオブジェクトを返すと仮定 }} 2. AjaxでPOSTリクエストを送信（データを送信） 適用シーン：フォーム送信、ユーザー登録、コメント送信など。 フロントエンド（HTML + JavaScript） 12345678910111213141516171819&lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;ユーザー名を入力&quot;&gt;&lt;button onclick=&quot;createUser()&quot;&gt;送信&lt;/button&gt;&lt;div id=&quot;response&quot;&gt;&lt;/div&gt;&lt;script&gt;function createUser() { let username = document.getElementById(&quot;username&quot;).value; fetch(&quot;http://localhost:8080/api/user&quot;, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot; }, body: JSON.stringify({ username: username, age: 25 }) }) .then(response =&gt; response.json()) .then(data =&gt; { document.getElementById(&quot;response&quot;).innerText = data.message; }) .catch(error =&gt; console.error(&quot;リクエストエラー:&quot;, error));}&lt;/script&gt; バックエンド（Spring BootでPOSTリクエストを処理） 1234567891011@RestController@RequestMapping(&quot;/api&quot;)public class UserController { @PostMapping(&quot;/user&quot;) public Map&lt;String, String&gt; createUser(@RequestBody User user) { Map&lt;String, String&gt; response = new HashMap&lt;&gt;(); response.put(&quot;message&quot;, &quot;ユーザー &quot; + user.getUsername() + &quot; の作成に成功しました&quot;); return response; }} 3. AjaxでPUTリクエストを送信（データの更新） 適用シーン：ユーザー情報の変更や記事の更新など。 フロントエンド（JavaScript） 123456789function updateUser() { fetch(&quot;http://localhost:8080/api/user&quot;, { method: &quot;PUT&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot; }, body: JSON.stringify({ username: &quot;吴&quot;, age: 26 }) }) .then(response =&gt; response.json()) .then(data =&gt; console.log(&quot;更新成功:&quot;, data));} バックエンド（Spring BootでPUTリクエストを処理） 12345@PutMapping(&quot;/user&quot;)public User updateUser(@RequestBody User user) { user.setAge(user.getAge() + 1); // 年齢を変更する仮定 return user;} 4. AjaxでDELETEリクエストを送信（データの削除） 適用シーン：ユーザーの削除や注文の削除など。 フロントエンド（JavaScript） 1234567function deleteUser() { fetch(&quot;http://localhost:8080/api/user/吴&quot;, { method: &quot;DELETE&quot; }) .then(response =&gt; response.text()) .then(data =&gt; console.log(&quot;削除成功:&quot;, data));} バックエンド（Spring BootでDELETEリクエストを処理） 1234@DeleteMapping(&quot;/user/{name}&quot;)public String deleteUser(@PathVariable String name) { return &quot;ユーザー &quot; + name + &quot; が削除されました&quot;;} まとめ リクエスト方法 適用シーン フロントエンドの例 バックエンドの例 GET データ検索 fetch(&quot;url&quot;) @GetMapping POST データ送信 fetch(&quot;url&quot;, { method: &quot;POST&quot;, body: JSON }) @PostMapping PUT データ更新 fetch(&quot;url&quot;, { method: &quot;PUT&quot;, body: JSON }) @PutMapping DELETE データ削除 fetch(&quot;url&quot;, { method: &quot;DELETE&quot; }) @DeleteMapping Axios AxiosはPromiseベースのJavaScript HTTPクライアントで、主にVue、React、Node.jsなどのフロントエンドフレームワークで使用され、Javaバックエンドとのデータ交換に利用されます。 Axiosは日本語では通常そのまま**“Axios”**という英単語で表現されます。技術関連の議論ではライブラリ名やフレームワーク名はそのまま英語で使われるのが一般的です。 もしAxiosがHTTPクライアントライブラリであることを説明したい場合は、次のように言うことができます： Axios は HTTP クライアントライブラリです。（AxiosはHTTPクライアントライブラリです。） Axiosの機能を具体的に説明したい場合は次のように言います： Axios を使うと、ブラウザで API にリクエストを送信できます。（Axiosを使うことで、ブラウザでAPIリクエストを送信できます。） 簡単に言うと、Axiosは通常そのまま英語の名前で使われ、日本語ではその機能を説明する形になります。 1. Axiosのインストール VueやReactプロジェクトの場合、npmを使ってインストールできます： 1npm install axios 通常のHTMLページで使用する場合は、次のようにCDNから読み込むことができます： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 2. AxiosでGETリクエストを送信（データを取得） 適用シーン：ユーザー情報の取得、データ検索など。 フロントエンド（AxiosでGETリクエストを送信） 1234567axios.get(&quot;http://localhost:8080/api/user&quot;, { params: { name: &quot;吴&quot; } }) .then(response =&gt; { console.log(&quot;ユーザー情報:&quot;, response.data); }) .catch(error =&gt; { console.error(&quot;リクエスト失敗:&quot;, error); }); バックエンド（Spring BootでGETリクエストを処理） 12345678@RestController@RequestMapping(&quot;/api&quot;)public class UserController { @GetMapping(&quot;/user&quot;) public User getUser(@RequestParam String name) { return new User(name, 25); }} 3. AxiosでPOSTリクエストを送信（データを送信） 適用シーン：ユーザー登録、フォーム送信など。 フロントエンド（AxiosでPOSTリクエストを送信） 12345678910axios.post(&quot;http://localhost:8080/api/user&quot;, { username: &quot;吴&quot;, age: 25}).then(response =&gt; { console.log(&quot;サーバーの返答:&quot;, response.data);}).catch(error =&gt; { console.error(&quot;リクエスト失敗:&quot;, error);}); バックエンド（Spring BootでPOSTリクエストを処理） 123456@PostMapping(&quot;/user&quot;)public Map&lt;String, String&gt; createUser(@RequestBody User user) { Map&lt;String, String&gt; response = new HashMap&lt;&gt;(); response.put(&quot;message&quot;, &quot;ユーザー &quot; + user.getUsername() + &quot; が作成されました&quot;); return response;} 4. AxiosでPUTリクエストを送信（データを更新） 適用シーン：ユーザー情報の変更や記事の更新など。 フロントエンド（AxiosでPUTリクエストを送信） 12345678910axios.put(&quot;http://localhost:8080/api/user&quot;, { username: &quot;吴&quot;, age: 26}).then(response =&gt; { console.log(&quot;更新成功:&quot;, response.data);}).catch(error =&gt; { console.error(&quot;リクエスト失敗:&quot;, error);}); バックエンド（Spring BootでPUTリクエストを処理） 12345@PutMapping(&quot;/user&quot;)public User updateUser(@RequestBody User user) { user.setAge(user.getAge() + 1); // 年齢を更新 return user;} 5. AxiosでDELETEリクエストを送信（データを削除） 適用シーン：ユーザーの削除、注文の削除など。 フロントエンド（AxiosでDELETEリクエストを送信） 1234567axios.delete(&quot;http://localhost:8080/api/user/吴&quot;) .then(response =&gt; { console.log(&quot;削除成功:&quot;, response.data); }) .catch(error =&gt; { console.error(&quot;リクエスト失敗:&quot;, error); }); バックエンド（Spring BootでDELETEリクエストを処理） 1234@DeleteMapping(&quot;/user/{name}&quot;)public String deleteUser(@PathVariable String name) { return &quot;ユーザー &quot; + name + &quot; は削除されました&quot;;} 6. Axiosのグローバル設定 VueやReactプロジェクトでAxiosをグローバルに設定し、コードの重複を減らすことができます： 12345678910import axios from &quot;axios&quot;;// デフォルトのbaseURLを設定axios.defaults.baseURL = &quot;http://localhost:8080/api&quot;;// グローバルリクエストヘッダーを設定axios.defaults.headers.common[&quot;Authorization&quot;] = &quot;Bearer token&quot;;// タイムアウト時間を設定axios.defaults.timeout = 5000; 7. Axiosインターセプターの使用（リクエスト＆レスポンスの処理） リクエストやレスポンスの際にトークンの処理やエラーメッセージの表示を自動で行いたい場合、インターセプターを使用できます： 123456789101112131415// リクエストインターセプター（リクエストヘッダーにTokenを追加する例）axios.interceptors.request.use(config =&gt; { config.headers.Authorization = &quot;Bearer token&quot;; return config;}, error =&gt; { return Promise.reject(error);});// レスポンスインターセプター（エラーハンドリングを統一化）axios.interceptors.response.use(response =&gt; { return response;}, error =&gt; { console.error(&quot;リクエストエラー:&quot;, error.response?.data || &quot;不明なエラー&quot;); return Promise.reject(error);}); まとめ リクエスト方法 適用シーン フロントエンドの例 バックエンドの例 GET データ取得 axios.get(&quot;url&quot;) @GetMapping POST データ送信 axios.post(&quot;url&quot;, data) @PostMapping PUT データ更新 axios.put(&quot;url&quot;, data) @PutMapping DELETE データ削除 axios.delete(&quot;url&quot;) @DeleteMapping XMLHttpRequest もし、最も基本的な方法（AxiosやFetch APIに依存せず）でのAjax通信を行いたい場合、**XMLHttpRequest**を使用できます。 1. GETリクエストを送信（データ取得） 適用シーン：ユーザー情報の取得、データ検索など。 フロントエンド（原生JavaScript） 12345678910111213141516&lt;button onclick=&quot;getUser()&quot;&gt;ユーザー情報を取得&lt;/button&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt;function getUser() { var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;http://localhost:8080/api/user?name=吴&quot;, true); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { var data = JSON.parse(xhr.responseText); document.getElementById(&quot;result&quot;).innerText = &quot;ユーザー名：&quot; + data.username; } }; xhr.send();}&lt;/script&gt; バックエンド（Spring BootでGETリクエストを処理） 12345678@RestController@RequestMapping(&quot;/api&quot;)public class UserController { @GetMapping(&quot;/user&quot;) public User getUser(@RequestParam String name) { return new User(name, 25); }} 2. POSTリクエストを送信（データ送信） 適用シーン：ユーザー登録、フォーム送信など。 フロントエンド（原生JavaScript） 123456789101112131415161718192021&lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;ユーザー名を入力&quot;&gt;&lt;button onclick=&quot;createUser()&quot;&gt;送信&lt;/button&gt;&lt;div id=&quot;response&quot;&gt;&lt;/div&gt;&lt;script&gt;function createUser() { var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;http://localhost:8080/api/user&quot;, true); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { var data = JSON.parse(xhr.responseText); document.getElementById(&quot;response&quot;).innerText = data.message; } }; var user = { username: document.getElementById(&quot;username&quot;).value, age: 25 }; xhr.send(JSON.stringify(user));}&lt;/script&gt; バックエンド（Spring BootでPOSTリクエストを処理） 123456@PostMapping(&quot;/user&quot;)public Map&lt;String, String&gt; createUser(@RequestBody User user) { Map&lt;String, String&gt; response = new HashMap&lt;&gt;(); response.put(&quot;message&quot;, &quot;ユーザー &quot; + user.getUsername() + &quot; が作成されました&quot;); return response;} 3. PUTリクエストを送信（データ更新） 適用シーン：ユーザー情報の更新や記事の編集など。 フロントエンド（原生JavaScript） 1234567891011121314function updateUser() { var xhr = new XMLHttpRequest(); xhr.open(&quot;PUT&quot;, &quot;http://localhost:8080/api/user&quot;, true); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { console.log(&quot;更新成功:&quot;, xhr.responseText); } }; var user = { username: &quot;吴&quot;, age: 26 }; xhr.send(JSON.stringify(user));} バックエンド（Spring BootでPUTリクエストを処理） 12345@PutMapping(&quot;/user&quot;)public User updateUser(@RequestBody User user) { user.setAge(user.getAge() + 1); // 年齢を1歳増やす return user;} 4. DELETEリクエストを送信（データ削除） 適用シーン：ユーザーの削除、注文の削除など。 フロントエンド（原生JavaScript） 123456789101112function deleteUser() { var xhr = new XMLHttpRequest(); xhr.open(&quot;DELETE&quot;, &quot;http://localhost:8080/api/user/吴&quot;, true); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { console.log(&quot;削除成功:&quot;, xhr.responseText); } }; xhr.send();} バックエンド（Spring BootでDELETEリクエストを処理） 1234@DeleteMapping(&quot;/user/{name}&quot;)public String deleteUser(@PathVariable String name) { return &quot;ユーザー &quot; + name + &quot; は削除されました&quot;;} まとめ リクエスト方法 適用シーン フロントエンドコード（XMLHttpRequest） バックエンドコード（Spring Boot） GET データ取得 xhr.open(&quot;GET&quot;, &quot;url&quot;) @GetMapping POST データ送信 xhr.open(&quot;POST&quot;, &quot;url&quot;) @PostMapping PUT データ更新 xhr.open(&quot;PUT&quot;, &quot;url&quot;) @PutMapping DELETE データ削除 xhr.open(&quot;DELETE&quot;, &quot;url&quot;) @DeleteMapping","link":"/Methods-of-Data-Transfer-Between-Frontend-and-Backend-in-Java-Projects/"},{"title":"JSPに取って代わった技術は何ですか？","text":"この記事では、JSP（JavaServer Pages）が新しい技術に取って代わられつつある現状について説明しています。代替技術として、Thymeleaf、Angular、React、Next.js、APIベースのアーキテクチャなどが挙げられ、それぞれの特徴と使用シーンについて触れています。また、JSPとThymeleafを用いたコードの比較を通じて、両者の違いを明確にし、Thymeleafの利便性とAJAXとの連携方法についても解説しています。 JSP（JavaServer Pages）は、Java EEテクノロジーで動的なWebページを構築するための従来の技術です。Web開発の進化に伴い、多くの新しいテクノロジーとフレームワークが登場し、徐々にJSPに取って代わりました。主な代替技術は以下の通りです。 1. テンプレートエンジン： Thymeleaf、FreeMarker、Velocityなどのテンプレートエンジンは、テンプレートとデータを組み合わせて動的コンテンツを生成します。JSPよりも柔軟で強力な構文と機能を提供します。 2. フロントエンドJavaScriptフレームワーク： Angular、React、Vue.jsなどのフレームワークは、AJAXやWebSocketを通じてバックエンドAPIと通信し、データを動的に取得・表示します。これにより、バックエンドのテンプレートエンジンの必要性が減少します。 3. サーバーサイドレンダリング（SSR）： Next.jsやNuxt.jsなどのNode.jsフレームワークは、サーバー側で動的ページを生成し、完全なHTMLとしてクライアントに返します。これにより、初期ロード時間の短縮やSEOの向上が期待できます。 4. マイクロサービスアーキテクチャとAPI設計： マイクロサービスアーキテクチャの普及により、フロントエンドとバックエンドを分離し、RESTful APIやGraphQLを通じて通信する設計が一般的になりました。バックエンドはSpring Boot、Express、Djangoなどの多様な技術でAPIを提供できます。 5. 静的サイトジェネレーター（SSG）： Gatsby、Jekyll、HugoなどのSSGは、Markdownファイルやデータを静的HTMLページに変換し、ランタイムサーバーなしでWebサーバーに直接デプロイできます。 JSPとThymeleafのコード比較 以下は、製品リストを表示する簡単なWebページのJSPとThymeleafのコード比較です。 JSPの使用: 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Product List&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Product List&lt;/h1&gt; &lt;ul&gt; &lt;% for (Product product : products) { %&gt; &lt;li&gt;&lt;%= product.getName() %&gt;&lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; Thymeleafの使用 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;&lt;http://www.thymeleaf.org&gt;&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Product List&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Product List&lt;/h1&gt; &lt;ul&gt; &lt;li th:each=&quot;product : ${products}&quot; th:text=&quot;${product.name}&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; Thymeleafは、Spring Bootのデフォルトテンプレートエンジンであり、より簡潔で表現力豊かな構文を提供します。 Thymeleaf の主な構文 Thymeleaf は、サーバー側とクライアント側の間で HTML をレンダリングするために使用される人気のあるテンプレートエンジンです。HTML ファイルに動的コンテンツとロジックを埋め込むための豊富なテンプレート構文をサポートしています。 Thymeleaf の一般的な構文をいくつか紹介します。 1. 変数式 **${...}** : JSP の EL 式と同様に、HTML で変数の値を出力するために使用されます。 1&lt;p&gt;Welcome, &lt;span th:text=&quot;${user.name}&quot;&gt;User&lt;/span&gt;&lt;/p&gt; 2. セレクタ式 ***{...}** : HTML 要素に属性を設定するために使用され、属性値は変数の値となります。 1&lt;input type=&quot;text&quot; th:value=&quot;*{user.email}&quot; /&gt; 3. URL 表現 **@{...}** : リンクの生成やリダイレクトに使用されます。 1&lt;a th:href=&quot;@{/products/details(id=${product.id})}&quot;&gt;Details&lt;/a&gt; 4. イテレータ式 **th:each** : コレクションをループし、各要素に対して HTML を生成するために使用されます。 123&lt;ul&gt; &lt;li th:each=&quot;product : ${products}&quot; th:text=&quot;${product.name}&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 5. 条件式 **th:if** 、 **th:unless** 、 **th:switch** 、 **th:case** : 条件に基づいて HTML 要素を制御します。 12&lt;div th:if=&quot;${product.stock &gt; 0}&quot;&gt;In Stock&lt;/div&gt;&lt;div th:unless=&quot;${product.stock &gt; 0}&quot;&gt;Out of Stock&lt;/div&gt; 6. インライン式 **#...** : 組み込み関数を使用して文字列やコレクションを操作できます。 1&lt;div th:text=&quot;${#strings.toUpperCase(product.name)}&quot;&gt;&lt;/div&gt; 7. フラグメント **th:fragment** 、 **th:replace** : テンプレートのモジュール化を実現します。 12345&lt;!-- フラグメントの定義 --&gt;&lt;div th:fragment=&quot;header&quot;&gt;Header&lt;/div&gt;&lt;!-- フラグメントの呼び出し --&gt;&lt;div th:replace=&quot;fragments/header&quot;&gt;&lt;/div&gt; 8. 国際化 **#{...}** : 国際化テキストの定義と参照に使用されます。 1&lt;span th:text=&quot;#{welcome.message}&quot;&gt;Welcome&lt;/span&gt; 9. 属性の動的設定 **th:attr** : HTML 要素の属性を動的に設定します。 1&lt;input type=&quot;text&quot; th:attr=&quot;placeholder=${user.name}&quot; /&gt; 10. 文字列リテラル **|...|** : 文字列を組み立てるために使用されます。 1&lt;span th:text=&quot;|Hello, ${user.name}!|&quot;&gt;&lt;/span&gt; 11. インライン JavaScript **th:inline** : JavaScript 内で Thymeleaf 変数を使用する際に活用します。 123&lt;script th:inline=&quot;javascript&quot;&gt; var name = [[${user.name}]];&lt;/script&gt; 12. コメント **&lt;!--/\\*...\\*/--&gt;** : Thymeleaf テンプレート専用のコメント。 1&lt;!--/* This is a Thymeleaf comment */--&gt; 13. フラグメントへのパラメータ渡し **th:with** : フラグメントに変数を渡します。 1&lt;div th:with=&quot;name=${user.name}&quot; th:replace=&quot;fragments/header&quot;&gt;&lt;/div&gt; 14. ページレイアウト **layout:decorator** : ページレイアウトを定義するために使用されます。 12&lt;html layout:decorator=&quot;layout.html&quot;&gt;&lt;/html&gt; 15. フィールド検証 **th:errors** : フォーム入力のバリデーションエラーを表示します。 1&lt;span th:errors=&quot;*{fieldName}&quot;&gt;&lt;/span&gt; 16. フォームバインディング **th:object** : フォームオブジェクトをバインドします。 12&lt;form th:object=&quot;${user}&quot; th:action=&quot;@{/save}&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 17. リストの空チェック **th:if** 、 **th:unless** : 変数が空かどうかを判断します。 1&lt;div th:if=&quot;${not #lists.isEmpty(products)}&quot;&gt;Product List&lt;/div&gt; Thymeleaf は、HTML ページをより柔軟に制御し、動的な動作を簡単に実装できるテンプレートエンジンです。公式ドキュメントを参照することで、さらに多くの機能を学ぶことができます。Thymeleaf の強力な機能とシンプルな構文により、Java Web 開発で広く利用されています。 Thymeleaf と Ajax の関係 Thymeleaf と Ajax は、Web 開発において異なる役割と用途を持つ 2 つの技術ですが、ユーザーエクスペリエンスと機能を向上させるために組み合わせて使用することができます。 Thymeleaf Thymeleaf は、サーバー側で HTML ページを生成するためのテンプレートエンジンです。動的コンテンツとロジックを HTML に埋め込むための豊富なテンプレート構文を提供し、サーバー側でページをレンダリングし、最終的な HTML ページをクライアントのブラウザに送信する役割を担います。 Ajax Ajax (Asynchronous JavaScript and XML) は、クライアントとサーバー間の非同期通信を可能にする技術です。ページ全体をリロードせずにサーバーとデータをやり取りできるため、より動的なユーザーインターフェースを実現できます。一般的に JavaScript を用いて Ajax リクエストを実装します。 Thymeleaf と Ajax の関係 Thymeleaf と Ajax を組み合わせることで、よりリッチでインタラクティブな Web アプリケーションを構築できます。たとえば、Thymeleaf でページの静的部分をサーバー側でレンダリングし、Ajax で動的なコンテンツを非同期にロードすることで、ページの応答速度を向上させることができます。 また、フォームの送信やユーザーの操作を Ajax で処理することで、ページをリロードすることなく部分的な更新が可能となり、より快適なユーザーエクスペリエンスを提供できます。 最新の Web 開発における Ajax の代替技術 Ajax は依然として有効な技術ですが、近年ではより高度で便利な技術やツールが利用されることが多くなっています。以下は、最新の Web 開発でよく使用される技術です。 1. フロントエンドフレームワーク (Angular、React、Vue.js など) これらのフレームワークはコンポーネントベースの開発を可能にし、状態管理やデータの取得を容易にするため、よりインタラクティブな Web アプリケーションの構築に適しています。 2. Fetch API Fetch API は、Promise ベースのインターフェースを提供し、シンプルかつ強力な方法で HTTP リクエストを処理できます。従来の XMLHttpRequest (XHR) の代替として広く利用されています。 3. Axios Axios は、Promise ベースの HTTP クライアントで、リクエストやレスポンスのインターセプター、JSON の自動変換などの機能を備え、ネットワークリクエストを簡単に管理できます。 4. WebSocket WebSocket は、クライアントとサーバー間に持続的な接続を確立し、リアルタイム通信を可能にするプロトコルです。チャットアプリやリアルタイム通知などに適しています。 5. Server-Sent Events (SSE) SSE は、サーバーからクライアントへの一方向のリアルタイム通信を提供する技術で、リアルタイムデータのストリーミングや通知に適しています。 まとめ 従来の Ajax も依然として利用されていますが、最新の Web 開発ではフロントエンドフレームワークや Fetch API、Axios、WebSocket などの技術が主流となっています。これらの技術を活用することで、より効率的で柔軟な Web アプリケーションの開発が可能になります。 ThymeleafとReactの類似点は何ですか Thymeleaf と React は、それぞれサーバーサイドレンダリングとクライアントサイドレンダリングに用いられる異なる技術ですが、いくつかの共通点もあります。 コンポーネント化 Thymeleaf: サーバーサイドでテンプレートを作成し、再利用可能なコンポーネントに分割できます。 th:replace や th:include などのディレクティブを使用して、複数のコンポーネントを組み合わせてページを構築できます。 React: コンポーネントベースの開発が可能で、独立したコンポーネントを組み合わせてアプリケーション全体を構築できます。コンポーネント化により、コードの再利用性、保守性、拡張性が向上します。 データバインディング Thymeleaf: HTML テンプレートにデータをバインドできます。 ${...} 式を用いてサーバー側のデータを取得し、ページにレンダリングできます。 React: 一方向データフローを採用し、props を介してデータを渡します。コンポーネント内で props の変更に応じて UI を再レンダリングできます。 条件付きレンダリングとループ Thymeleaf: th:if、th:unless による条件分岐、th:each によるコレクションの繰り返しレンダリングが可能です。 React: JavaScript の &amp;&amp; や三項演算子 ? : を用いた条件分岐、map() によるリストレンダリングが可能です。 イベント処理 Thymeleaf: サーバーサイドレンダリングを主目的とするため、直接的なイベント処理は提供されません。クライアント側の JavaScript を併用する必要があります。 React: onClick や onChange などのイベントハンドラを用いて、柔軟なイベント処理が可能です。 仮想 DOM Thymeleaf: サーバーサイドで HTML を生成し、ブラウザに送信するため、仮想 DOM は使用しません。 React: 仮想 DOM を利用し、変更があった部分のみを効率的に更新することで、レンダリングのパフォーマンスを向上させます。 Thymeleaf と React は、それぞれ異なる目的に特化した技術ですが、コンポーネント化、データバインディング、条件付きレンダリング、ループレンダリングの概念には共通点があります。プロジェクトの要件に応じて適切な技術を選択することが重要です。 最新の Web 開発における Ajax 以外の主要技術 現代の Web 開発では、Ajax 以外にもさまざまな技術やツールが活用されています。これらは Web アプリケーションの動的な機能を強化し、開発者の生産性を向上させる役割を果たします。 1. フロントエンドフレームワーク（Angular、React、Vue.js など） これらのフレームワークは、複雑なクライアントサイドのインタラクションを効率的に管理する機能を提供します。特に、コンポーネントベースのアーキテクチャと状態管理機能が強力で、リアルタイムでデータを更新することが可能です。 React：仮想 DOM による高速レンダリングを実現し、Redux などの状態管理ライブラリと組み合わせて使われることが多い。 Vue.js：シンプルな構文と双方向データバインディングを提供し、axios や fetch との統合も容易。 Angular：大規模アプリ向けのフルスタックフレームワークで、独自の HTTP クライアントやリアクティブプログラミングをサポート。 2. Fetch API Fetch API は、Ajax の後継として広く使用される技術で、Promise ベースで非同期通信を直感的に実装できます。 1234fetch('/api/data') .then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(error =&gt; console.error('Error:', error)); 3. Axios Axios は、Promise ベースの HTTP クライアントで、リクエスト・レスポンスのインターセプターやエラーハンドリング機能を提供します。 123axios.get('/api/data') .then(response =&gt; console.log(response.data)) .catch(error =&gt; console.error('Error:', error)); 4. WebSocket WebSocket は、クライアントとサーバー間でリアルタイムの双方向通信を可能にする技術です。チャットアプリやリアルタイム通知に適しています。 1234const socket = new WebSocket('ws://example.com/socket');socket.onmessage = (event) =&gt; { console.log('Message received: ' + event.data);}; 5. Server-Sent Events (SSE) SSE は、サーバーからクライアントへ一方向のリアルタイム更新を提供する技術で、株価のリアルタイム表示や通知システムに活用されます。 1234const eventSource = new EventSource('/api/updates');eventSource.onmessage = function(event) { console.log('New message:', event.data);}; まとめ 現在の Web 開発では、Ajax に代わり フロントエンドフレームワーク、Fetch API、Axios、WebSocket、SSE などの技術が広く活用されています。これらを適切に組み合わせることで、よりインタラクティブでリアルタイム性の高い Web アプリケーションを構築することが可能です。","link":"/What-technology-has-replaced-JSP/"},{"title":"WBSの管理方法、タスクの割り当て、進捗報告の方法","text":"この文章では、WBSの管理方法、タスクの割り当て、進捗報告について解説しています。特に、3〜5人のSubleaderとして小規模なプロジェクトを担当する際に、効率的な進捗管理の方法やタスクの分解、優先順位設定の重要性について具体的なアドバイスを提供します。チームの進捗を正確に把握し、プロジェクトの成功に導くためのポイントが紹介されています。 WBSの管理方法、タスクの割り当て、進捗報告について、3〜5人のSubleaderとして、いくつかの小さな案件やプロジェクトを担当する場合、進捗を把握することが重要です。 管理の方法 1. 明確なWBSを作成する タスクの分解：まず、プロジェクトを小さなタスクに分解し、各タスクに明確な目標と納品物を設定します。WBSはプロジェクト全体の構造を把握するのに役立ち、詳細な管理が可能になります。 タスクの優先順位と依存関係：各タスクに優先順位を設定し、タスク間の依存関係を明確にします。これにより、チームメンバーは優先順位に従って作業を進め、リソースの無駄を避けることができます。 2. タスクの割り当て 作業負荷のバランス：チームメンバーのスキルや経験に基づいて、タスクを適切に割り当てます。タスクの難易度や複雑さに応じて、負担が均等になるように配慮します。 責任の明確化：各タスクには責任者と期限を設定し、責任が曖昧にならないようにします。これにより、タスクの進捗が遅れるリスクを減らせます。 3. 進捗報告 定期的な進捗更新：毎日または毎週の進捗会議を設定し、各メンバーの作業状況を確認します。進捗が遅れている場合には早期に問題を発見できます。 進捗管理ツールの利用：JiraやTrello、Excelなどのツールを使用してタスクの進捗を追跡します。これにより、タスクの現在の状況を視覚的に把握できます。 適時調整：遅延やボトルネックが発生した場合、速やかにチームメンバーと連携し、実際の状況に応じて調整します。リソースの再配分や作業フローの最適化を行うことが必要です。 4. リスク管理と問題解決 リスクの事前特定：プロジェクトの初期段階で、進捗に影響を与える可能性のあるリスク（技術的な問題、チーム内の協力不足など）を特定し、それに対する対策を準備します。 問題の早期解決：タスク実行中に問題が発生した場合、すぐに介入して解決します。例えば、技術的な課題や調整の問題が発生した場合、早期に対応することで問題の拡大を防げます。 5. モチベーションとコミュニケーション チーム内のコミュニケーション：チームメンバーとの良好なコミュニケーションを維持し、進捗状況を定期的に確認して調整を行います。 適切なモチベーション：良い成果を上げたメンバーには適切な評価とフィードバックを行い、チームの士気を高め、協力関係を強化します。 6. 振り返りと改善 プロジェクト後の振り返り：プロジェクト完了後に振り返りを行い、良かった点や改善点をまとめます。経験を積むことで、次回のプロジェクトに生かすことができます。 WBS 作成 Excelを使ってWBSを作成する場合、以下の手順に従って作業を進めることができます。 1：プロジェクト構造の決定 まず、プロジェクトの主要なフェーズやタスクを特定し、プロジェクトを複数のタスクに分解します。各タスクは、納品物や成果物が明確で、タスク間には依存関係がある場合があります。 2：WBS用のExcel表の作成 ExcelでWBSを作成するためには、以下のカラムを設定します： タスク番号（Task ID）：各タスクやサブタスクには一意の番号を付けます。 タスク名（Task Name）：タスクの簡単な説明や名前。 タスクレベル（Level）：タスクがWBS内でどのレベルにあるか（例：1はメインタスク、2はサブタスクなど）。 担当者（Owner）：そのタスクを担当する人物。 開始日（Start Date）：タスクの開始日。 終了日（End Date）：タスクの終了日。 ステータス（Status）：タスクの進行状況（未開始、進行中、完了など）。 依存関係（Dependencies）：前のタスク番号や名前を記入し、タスクの順番を明確にします。 3：タスク情報を入力 タスク番号の設定：プロジェクトの分解に基づいて、各タスクに番号を付けます。メインタスクには「1」、サブタスクには「1.1」「1.2」などの番号を付けます。 タスク名の入力：各タスクの名前を簡潔に記入します。 レベルの設定：タスクの階層を番号で示します。例えば、メインタスクは「1」、サブタスクは「1.1」「1.1.1」などと設定します。 担当者の割り当て：各タスクの担当者を指定します。 日付とステータスの入力：各タスクの開始日と終了日を記入し、進行状況を「未開始」「進行中」「完了」などで管理します。 依存関係の記入：タスク間の依存関係をリストにしておくことで、タスクの順番を確認できます。 4：Excelの機能を活用する セルの結合：親タスクとサブタスクの関係を視覚的に区別するために、セルを結合して階層を表現できます。 色分け：タスクの進行状況に応じて色を変更します。例えば、「進行中」は黄色、「完了」は緑色、「遅延」は赤色などで設定できます。 自動計算：期間や作業時間を自動で計算するための数式を設定できます。例えば、終了日から開始日を引いてタスクの所要日数を計算することができます。 ガントチャートの作成：Excelには、条件付き書式を使って簡単にガントチャートを作成する機能があります。これにより、タスクの進捗が一目でわかるようになります。 サンプルWBS表 タスク番号 タスク名 レベル 担当者 開始日 終了日 ステータス 依存関係 1 プロジェクト開始 1 山田太郎 2025/03/01 2025/03/03 進行中 1.1 要件定義 2 鈴木花子 2025/03/02 2025/03/07 進行中 1 1.1.1 要件収集 3 佐藤次郎 2025/03/02 2025/03/04 完了 1.1 1.1.2 要件仕様書作成 3 高橋一郎 2025/03/05 2025/03/07 未開始 1.1 1.2 設計フェーズ 2 中村大輔 2025/03/08 2025/03/14 未開始 1.1 1.2.1 システム設計 3 加藤健 2025/03/08 2025/03/10 未開始 1.2 1.2.2 データベース設計 3 小林正 2025/03/11 2025/03/14 未開始 1.2 ステップ 5：進捗の追跡 進捗バーの作成：Excelで進捗を視覚的に示すために、条件付き書式を使って進捗バーを作成できます。 動的な更新：Excelファイルをチームで共有し、各メンバーが進捗を更新できるようにすることで、プロジェクトの進行状況をリアルタイムで確認できます。 小技： データ検証：ステータス列に「未開始」「進行中」「完了」などの項目を設定し、データの統一性を保ちます。 コメントの追加：タスクの詳細や問題点をExcelのセルにコメントとして追加し、後から参照できるようにします。 Excelは専用のプロジェクト管理ツールではありませんが、適切に設定すれば、WBSの管理に十分活用できます。プロジェクトが小規模な場合や柔軟な管理が求められる場合に非常に有効なツールです。 WBS管理ツール プロジェクト管理において、WBS（作業分解構造）を管理するためのソフトウェアは多数あります。以下は、WBS管理に役立つ一般的なツールです： Microsoft Project Microsoft Projectは、非常に強力なプロジェクト管理ソフトウェアで、WBSの作成と管理をサポートしています。グラフィカルなインターフェースでタスク分解、依存関係の設定、リソースの割り当てが可能です。 Trello Trelloは、看板ベースのプロジェクト管理ツールで、主にタスク管理に特化していますが、複数のボードとリストを作成することでWBSを実現することができます。チームとのコラボレーションにも非常に便利です。 Jira Jiraは、アジャイル開発向けのプロジェクト管理ツールで、WBSを作成してタスクの進捗を追跡する機能があります。強力な問題追跡機能があり、開発チームに適しています。 Asana Asanaは、タスクとプロジェクト管理ツールで、タスク、サブタスク、プロジェクトの作成によりWBS管理をサポートします。シンプルで使いやすく、チームでの協力作業に適しています。 Smartsheet Smartheetは、Excelに似たインターフェースを持つプロジェクト管理ツールで、タスクのドラッグ＆ドロップによりWBSを作成できます。依存関係や優先順位の設定が簡単で、WBSの管理に便利です。 Wrike Wrikeは、チーム協力とプロジェクト管理をサポートするプラットフォームで、WBSビュー機能を提供しています。タスクを分解し、リソースを割り当てて進捗を追跡できます。 ClickUp ClickUpは、多機能なプロジェクト管理ツールで、タスク管理、目標設定、WBSの作成が可能です。豊富な機能を提供し、さまざまな規模のチームに適しています。 Monday.com Monday.comは、非常に直感的で使いやすいプロジェクト管理ツールで、WBSの作成と管理をサポートします。カスタマイズ可能なビューを使用して、プロジェクトタスクを整理し、進捗を追跡できます。 TeamGantt TeamGanttは、オンラインGanttチャートツールで、WBS機能をサポートしています。タスクを分解し、Ganttチャートで直感的に進捗を表示することができます。 Basecamp Basecampは、チーム協力ツールで、中小規模のチームに最適です。専用のWBS機能はありませんが、タスクリストやディスカッションを使ってタスク管理を行い、間接的にWBSを管理できます。","link":"/WBS-management-task-assignment-progress/"},{"title":"障害対応および影響調査の際に準備すべき資料","text":"障害対応や影響調査を行う際、必要な資料を的確に準備することは非常に重要です。これにより、障害発生時に迅速かつ効果的に対応でき、関係者への報告や再発防止策を立案するための基盤が築かれます。以下に、障害対応および影響調査において準備すべき資料を示します。これにより、障害発生から復旧までの過程が明確になり、再発防止策の立案に役立ちます。 1. 障害の詳細説明 障害の詳細を正確に記載することは、原因の特定とその後の対応において最も重要なステップです。具体的には以下の内容を含める必要があります： 障害のタイプ：ハードウェア故障、ソフトウェアバグ、ネットワーク問題、セキュリティ侵害など、障害がどのようなタイプであるかを明確にします。 発生日時と発生状況：障害が発生した日時、発生の前後の状況、例えばシステムの負荷やエラーの兆候なども記録します。 影響範囲：障害によって影響を受けたシステムやサービス、ユーザーグループ、部門などを記載します。これにより、障害の重要性を客観的に評価することができます。 2. 影響分析報告 影響分析は、障害が業務に与えた影響を評価し、今後の対応策を考える上で欠かせない資料です。具体的な内容は以下の通りです： 影響の程度：障害がどの程度の影響を業務やサービスに与えたかを評価します。例えば、サービス停止時間、業務遅延、顧客への影響などを考慮します。 影響を受けたシステム・プロセス：障害によってどのシステムや業務プロセスが影響を受けたのかを特定します。これにより、障害の範囲を把握し、今後の予防策を講じるためのデータを収集します。 関係者の影響：影響を受けたユーザーや部門、顧客などの関係者を特定し、それらの対応策を記載します。また、顧客や取引先にどのような影響があったかを整理し、必要な対応を行います。 3. 根本原因分析 障害の根本原因を特定するための詳細な分析が必要です。これにより、同様の問題を再発させないための根本的な対策を講じることができます。以下の点を分析します： 直接的な原因：例えば、ソフトウェアのバグ、ハードウェアの故障、設定ミスなど、問題の直接的な原因を明確にします。 間接的な原因：例えば、プロジェクトマネジメントの不備、テスト不足、人的ミスなど、障害を引き起こした背景やシステムの脆弱性なども考慮します。 原因特定方法：ログ解析、システム監視ツール、障害再現テストなどを使用して、根本的な原因を突き止めます。 4. 対応措置 障害発生後に講じた対応策を詳細に記録します。この段階では、以下の内容が含まれます： 短期的な対応策：障害発生後の緊急対応として、システムの一時的修正、再起動、パッチの適用など、迅速に行った対応策を記録します。 長期的な対応策：障害の再発防止やシステム改善のための根本的な対策を記録します。例えば、システムの構造変更、運用プロセスの改善、監視体制の強化などが考えられます。 5. 復旧状況と進捗 復旧作業の進捗を詳細に記録することも重要です。これにより、復旧までの過程を追跡し、必要に応じて追加のリソースを投入することができます。以下の情報を記載します： 復旧の開始時期：障害発生後、復旧作業をいつ開始したかを記録します。 進捗状況：復旧作業がどの程度進んでいるか、現状の進捗を報告します。 完全復旧の達成状況：復旧作業が完了したか、新たな問題が発生したかどうかも記載します。 6. リスク評価 同様の障害が再発するリスクを評価し、その予防策を提案します。以下の要素を評価します： 再発リスク：障害がどの程度再発する可能性があるか、過去の障害と比較してリスクの高い点を分析します。 予防策：再発を防ぐための技術的な対策、運用上の改善策、人的なトレーニングの強化など、具体的な予防策を提案します。 7. コミュニケーション記録 障害が顧客や重要な関係者に影響を与えた場合、適切なコミュニケーションが求められます。以下の内容が含まれます： 通知の記録：顧客への通知や、社内への報告など、障害発生時の通知の内容を記録します。 報告書の提出：進捗報告や最終報告書を作成し、関係者に適切に提供します。 コミュニケーション内容：関係者との会話やメール、会議の内容なども記録します。これにより、後の対応策を振り返ることができます。 これらの資料を適切に準備することで、障害発生時の迅速な対応と、影響を最小限に抑えることができます。さらに、再発防止策を講じるための貴重なデータとなり、企業全体の信頼性向上に貢献します。","link":"/Materials-to-prepare-for-incident-response-and-impact-investigation/"},{"title":"プロジェクトが遅延している場合の対応策","text":"プロジェクトが遅延している場合、プログラマーやシステムエンジニアは、遅延の原因を分析し、チームとのコミュニケーションを強化し、プロジェクト計画を見直して進捗を加速する必要があります。問題解決のための是正措置を講じ、遅延の影響を最小限に抑えるため、関係者への報告と調整を行います。また、プロジェクト終了後には振り返りと改善を行い、次回の遅延を防ぐための対策を講じます。 项目が遅延している場合、PG（プログラマー）またはSE（システムエンジニア）として取るべき対応策は、以下の順序で実施することが重要です： 遅延の原因を分析する プロジェクトの遅延の原因を詳細に分析することが最も重要です。 遅延の原因には、要件変更、技術的な問題、リソース不足、チーム内でのコミュニケーション不足などが考えられます。 まず、プロジェクトマネージャーやチームメンバーとコミュニケーションを取り、問題の根本的な原因を特定します。技術的な課題がある場合、システム設計やアーキテクチャを再検討し、根本的な問題を特定することが必要です。 また、要件変更が影響を与えている場合は、変更内容の優先度を再確認することが重要です。 チームとコミュニケーションを取る 遅延がチーム内の問題に起因している場合、迅速にプロジェクトマネージャーやチームメンバーと連絡を取り、現在の進捗状況を確認します。 チームメンバーそれぞれの作業内容を把握し、どこで問題が発生しているのかを理解します。 必要に応じて、作業の優先順位を再調整し、リソースの再配分を行います。 チーム全体が同じ目標に向かって進んでいるかどうかを確認し、全員が自分の役割を理解していることを確認することが重要です。 プロジェクト計画を見直す 遅延の原因を特定した後、プロジェクト計画を再評価します。 スケジュールやリソース配分が現状に合っているかどうかを確認し、改善策を提案します。 作業の再優先順位をつけ、遅延を取り戻すためにどの作業を加速できるかを検討します。 また、納期に間に合わせるために、現実的なスケジュールに修正を加えます。これにより、現状の問題に対処しながら、無理なく進行できる計画を立てます。 進捗加速のための是正措置を講じる 遅延を取り戻すために、加速措置を講じる必要があります。例えば、残業の実施や、作業フローの改善を行うことが考えられます。 非効率な部分を特定し、改善するための手段を講じます。 作業効率を向上させるために、ツールの導入やプロセスの見直しを行うことも有効です。 チームメンバーの作業負担を適切に調整し、最も効率的に進められる方法を見つけます。 顧客や上司への報告と調整 遅延が避けられない場合、早急に顧客や上司に報告し、遅延の理由を説明します。 納期の調整や他の対応策について相談し、理解を得ることが重要です。 遅延の原因とともに、今後の進行計画について説明し、新たな納期を提案します。 顧客や上司が納得する形で、調整を進めることが信頼を保つために不可欠です。 振り返りと改善 プロジェクト終了後には、遅延の原因とその対応策を振り返り、次回同様の問題が発生しないように改善点を見つけます。 どの段階で問題が発生したのか、チーム内でどのように対応したのかをレビューし、教訓を得ます。 これにより、次回のプロジェクトで同じ失敗を繰り返さないようにするための対策を講じます。 関係者への通知 遅延が発生した時点で、速やかに顧客、チームメンバー、経営陣など関係者に通知し、遅延の原因と予想される完了時期を報告します。 透明性を保ちつつ、関係者の不安を軽減し、信頼を維持するために定期的に更新を行います。 リスク評価と対応策 プロジェクトの進行中に新たなリスクが発生する可能性があります。 そのため、今後発生しうるリスクを評価し、適切な対応策を立てます。例えば、外部要因や技術的な障害が再発する可能性について予測し、リスクを最小化するための事前対策を講じます。 コミュニケーションの強化 チーム内でのコミュニケーションを円滑にし、定期的にプロジェクトの進捗を確認します。 問題が早期に発見されれば、迅速に対応できるため、定期的な進捗会議やレビューを設け、情報共有を密にします。 コミュニケーションの強化により、チーム全体が同じ方向に進むことができます。 10. 定期的な進捗報告 顧客や経営陣に定期的に進捗状況と是正措置を報告します。進捗報告は透明性を保ちながら、信頼関係を築くために重要です。遅延の進行状況や新たなリスク、改善策について適宜報告を行い、関係者が常にプロジェクトの状況を把握できるようにします。 これらの対応策を講じることで、遅延を取り戻し、プロジェクトをスムーズに進行させることができます。","link":"/Measures-for-handling-project-delay/"},{"title":"ウォーターフォールモデル各段階の成果物","text":"ウォーターフォールモデルは、ソフトウェア開発において各工程を順番に進める開発モデルです。このモデルでは、各段階ごとに明確な成果物（ドキュメントやシステム成果）を作成し、次の工程へと引き継ぎます。本記事では、ウォーターフォールモデルの主要な段階と、それぞれの成果物について概説します。 日本の大型プロジェクトの開発におけるウォーターフォールモデルでは、通常、厳密な段階的なプロセスに従って進行します。 「要件定義」、「基本設計」、「詳細設計」、「単体テスト」、「結合テスト」に加えて、以下のような段階もあります： システム統合テスト（System Integration Testing）：この段階では、すべてのモジュールやサブシステムが統合され、システム全体の機能や性能がテストされます。コンポーネント間の連携がスムーズに行われるか確認します。 受け入れテスト（Acceptance Testing）：顧客やユーザーがプロジェクトの要求に基づいて、ソフトウェアが機能や性能の要件を満たしているかを検証します。納品が顧客の要求に適合していることを確認する段階です。 デプロイ（Deployment）：開発が完了したソフトウェアを本番環境にデプロイし、最終的なセットアップ作業を行い、必要な環境設定を実施します。 保守（Maintenance）：ソフトウェアが納品された後、保守段階に入ります。この段階では、バグの修正、パフォーマンスの最適化、新たな要求への対応などが行われます。 これらの段階は通常、順番に実行され、各段階の結果が次の段階に影響を与えることになります。 要件定義 要件定義段階では、以下のような入力資料（Input）と段階終了後の成果物があります。 入力資料（Input）： 顧客の要求：顧客が求めるソフトウェアの機能、性能、インターフェース、操作方法などの基本的な要求。 既存システムの文書：既存システムの改善や拡張の場合、既存システムの文書やアーキテクチャ設計が参考資料となります。 業務フローやルール：システムがサポートする業務フローや規則、規範に関する情報。各業務の具体的な操作を理解する必要があります。 法令や業界標準：プロジェクトが関わる業界における関連法令や規制、標準に準拠する必要がある場合、それらを考慮する必要があります。 市場分析：プロジェクトが属する市場環境や競合製品など、市場ニーズや方向性を把握するための分析資料。 関係者（stakeholder）の意見：プロジェクトマネージャー、開発チーム、テストチームなど、関係者からの意見やアドバイス。 技術的な要求と制約：使用する技術基盤、プラットフォーム、ツール、技術的な制約や特殊な要件に関する資料。 成果物（Deliverables）： 要件定義書：顧客とユーザーの要求を明確に、詳細に記述したドキュメントで、システムが備えるべき機能や性能について説明されます。後の設計や開発の基礎となります。 ユースケース図：システムとユーザー間のインタラクションを示すユースケース図。システムの動作の流れを視覚的に表現します。 機能要件文書：システムが実現する必要がある機能を詳細に列挙し、入力、出力、動作などを記述します。 優先度リスト：各要件の優先度を整理し、開発時に重要度や緊急度に基づいて処理する順序を決定します。 非機能要件文書：性能、セキュリティ、信頼性、保守性など、システムの非機能的な要求を文書化したもの。 これらの成果物は、次の段階の設計や開発に向けた基盤となり、チーム全体が同じ目標に向かって進むための重要な指針となります。 基本設計 基本設計段階では、以下のような入力資料（Input）と段階終了後の成果物があります。 入力資料（Input）： 要件定義書：基本設計段階の中心的な入力資料で、機能要件、非機能要件、優先度などの詳細情報が含まれ、これが後の設計作業の基盤となります。 業務フロー文書：業務プロセスや規則を記載した文書で、設計者がシステムの実際の運用シナリオやフローを理解するために役立ちます。 既存システムのアーキテクチャ文書：既存システムの改修や拡張がある場合、既存システムのアーキテクチャ設計文書が重要で、システムの構造や制約を理解するために必要です。 技術的要求文書：システムの性能、プラットフォーム、ツール選定などの技術的な制約や要求が記載されており、基本設計に影響を与えます。 法令や規制に関する要求：プロジェクトに関連する法令や業界規格、安全要件などが、設計に影響を与える場合があります。 開発チームおよび関係者のフィードバック：開発チーム、テストチーム、運用チームなどからの意見や提案が、設計の実現可能性と保守性を高めるために重要です。 成果物（Deliverables）： システムアーキテクチャ設計書：システム全体のアーキテクチャを記述し、モジュールの分割、サブシステム間のインタラクション、データフロー、機能の割り当てなどを定義します。 インターフェース設計書：システムの各モジュール間のインターフェース規格を詳細に定義し、入力・出力フォーマット、データ交換方法、プロトコルなどを明記します。 データベース設計書：システムにデータベースが関わる場合、基本設計段階でデータベースの初期設計を行い、テーブル、データ関係、インデックスなどを定義します。 高レベルの技術的アーキテクチャ案：システムの技術選定、開発プラットフォーム、フレームワークなどに関する高レベルな設計案を提供します。 システムフローチャートやユースケース図：システムの処理フローやユーザーとシステム間のインタラクションを示す図で、開発チームにシステムの動作理解を助けます。 非機能要件の設計文書：システムの性能、安全性、信頼性など、非機能的な要求に対する設計案をまとめます。 これらの成果物は、詳細設計段階の基礎となり、システムのアーキテクチャや設計案が実際の開発に進むための指針を提供します。 詳細設計 詳細設計段階では、以下のような入力資料（Input）と段階終了後の成果物があります。 入力資料（Input）： 基本設計書：システムのアーキテクチャ設計、モジュール分割、インターフェース定義などが記載された基本設計書を基に、詳細設計を進めます。 要件定義書：詳細設計段階では、すべての機能要件と非機能要件を満たすように設計を進めるため、要件定義書が重要な入力資料となります。 インターフェース設計書：システム内外のモジュール間のインターフェース設計を詳細化し、データ形式やパラメータ、返却値、エラーハンドリングの仕様を定義します。 データベース設計書：プロジェクトでデータベースを使用する場合、データベースの詳細設計（テーブル構造、インデックス、データ関係など）が詳細設計の入力資料になります。 技術アーキテクチャ設計書：システムアーキテクチャにおいて選定された技術スタックやプラットフォームを基に、詳細設計を進めます。 セキュリティおよびパフォーマンス要件文書：システムのパフォーマンスや拡張性、セキュリティ要件に対応するため、これらの非機能的な要件が詳細設計に影響を与えます。 開発ツールやフレームワークの文書：使用する開発ツールやフレームワークに関する文書が必要で、詳細設計の段階でそれらに適した設計を行います。 成果物（Deliverables）： モジュール設計書：各モジュールの詳細な設計を記述し、クラス図、オブジェクト図、データフロー、アルゴリズム、データ構造などを含めます。これが開発者の実装基盤となります。 データベース設計書：データベースのテーブル構造、フィールド定義、データ間の関係、外部キー制約、インデックス設計などを詳細に記述します。 インターフェース設計書：モジュール間のインターフェース詳細設計を行い、入力・出力フォーマット、プロトコル、エラーコード、処理方法などを定義します。 技術設計書：各モジュールの実装技術、選定したプログラミング言語、フレームワーク、ツールの使用方法などを記載した技術的な設計書です。 テストケース文書：詳細設計に基づいて、各機能のテストケースを作成し、設計が正しく実装されることを確認します。 パフォーマンス要件設計書：システムのレスポンスタイム、スループット、同時処理能力などのパフォーマンス要件に対応した設計を行います。 セキュリティ設計書：システムの認証、認可、暗号化、データセキュリティなど、セキュリティ要件を満たすための設計書です。 これらの成果物は、システムの実装に向けた詳細な情報を開発者に提供し、テストチームにとっては設計が正しく実装されていることを確認するための基盤となります。 テスト ソフトウェア開発におけるテスト設計段階で、テストケース文書（通常は「テスト仕様書」と呼ばれます）の作成は、システムの品質を保証するために非常に重要です。テストケースは、テストの深さやシステムの構造に応じて、「メソッド単位」または「クラス全体単位」で作成されることがあります。以下にテスト仕様書の作成方法とテストの網羅性を確保するための方法について説明します。 テスト仕様書の作成方法： テスト仕様書には通常、以下の情報が含まれます。 テストケースID（Test Case ID）：各テストケースに一意の番号を付与し、管理しやすくします。 テストケース名（Test Case Name）：テストの目的や機能を簡潔に示した名前。 テストの説明（Test Description）：テストケースの目的と検証内容の概要。 前提条件（Pre-conditions）：テストを実行する前に満たすべき条件やシステムの状態。 テスト手順（Test Steps）：テスト実行のための詳細な手順。 期待結果（Expected Results）：テスト実行後に期待される結果。 実際の結果（Actual Results）：テスト実行後に得られた実際の結果（通常はテスト実行時に記入）。 テストデータ（Test Data）：テスト中に使用される入力データやテスト環境の設定。 テスト環境（Test Environment）：テストに必要なハードウェア、OS、ソフトウェアバージョンなどの環境設定。 優先度（Priority）：テストケースの重要度や不具合の影響度に基づいて設定。 ステータス（Status）：テストケースの実行状態（例：「成功」「失敗」「ブロック中」など）。 メソッド単位でのテストか、クラス全体単位でのテストか？ テストはプロジェクトの要求に応じて、メソッド単位やクラス全体単位で行います。 メソッド単位のユニットテスト：通常、開発者は各メソッド単位でテストを行い、関数やメソッドが期待通りに動作するかを確認します。ユニットテストは、JUnitやTestNGなどのツールを使用して自動化できます。 クラス単位の統合テスト：メソッド単位のテストが完了したら、次はクラスやモジュール単位で統合テストを行い、複数のメソッドが協調して動作することを確認します。 システム全体テスト：システム全体またはサブシステムの機能テストは、ユーザー視点でシステム全体の動作を確認することに焦点を当てます。 テストの網羅性をどう確保するか？ テストの網羅性を確保するためには、以下のアプローチが有効です。 カバレッジ分析：コードカバレッジツール（JaCoCo、Coberturaなど）を使用して、テストがコードの重要な部分や分岐点を網羅していることを確認します。 機能テストと非機能テストの組み合わせ： 機能テスト：システムが基本的な機能やビジネス要件を満たしているかを検証します。 非機能テスト：性能、安全性、可用性などの非機能要件が満たされているかを確認します。 テスト設計手法： 境界値分析：入力データの境界値をテストし、システムが極端なケースに適切に対応するかを確認します。 同値クラステスト：入力データを同値クラスに分け、それぞれの代表値をテストします。 状態遷移テスト：システムが状態遷移を伴う場合、状態遷移図を使って各状態の動作をテストします。 自動化テスト：Selenium、JUnit、Appiumなどのツールを使用して、テストの効率を向上させ、多くのテストケースをカバーできます。 回帰テスト：コードの変更や更新に対して、回帰テストを行い、新たなバグが発生していないかを確認します。 ユーザー受け入れテスト（UAT）：最終ユーザーによる受け入れテストを実施し、システムがユーザーの期待に応えているかを確認します。 これらの方法を組み合わせて使用することで、テストの網羅性を確保し、システムの品質を高めることができます。","link":"/Deliverables-of-each-stage-of-the-waterfall-model/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Junit","slug":"Junit","link":"/tags/Junit/"},{"name":"テスト","slug":"テスト","link":"/tags/%E3%83%86%E3%82%B9%E3%83%88/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","link":"/tags/XMLHttpRequest/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"Thymeleaf","slug":"Thymeleaf","link":"/tags/Thymeleaf/"},{"name":"fetch","slug":"fetch","link":"/tags/fetch/"},{"name":"WBS","slug":"WBS","link":"/tags/WBS/"},{"name":"進捗管理","slug":"進捗管理","link":"/tags/%E9%80%B2%E6%8D%97%E7%AE%A1%E7%90%86/"},{"name":"障害対応","slug":"障害対応","link":"/tags/%E9%9A%9C%E5%AE%B3%E5%AF%BE%E5%BF%9C/"},{"name":"影響調査","slug":"影響調査","link":"/tags/%E5%BD%B1%E9%9F%BF%E8%AA%BF%E6%9F%BB/"},{"name":"設計","slug":"設計","link":"/tags/%E8%A8%AD%E8%A8%88/"},{"name":"ウォーターフォール","slug":"ウォーターフォール","link":"/tags/%E3%82%A6%E3%82%A9%E3%83%BC%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A9%E3%83%BC%E3%83%AB/"}],"categories":[{"name":"技術概要","slug":"技術概要","link":"/categories/%E6%8A%80%E8%A1%93%E6%A6%82%E8%A6%81/"},{"name":"フロントバック通信","slug":"フロントバック通信","link":"/categories/%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%83%90%E3%83%83%E3%82%AF%E9%80%9A%E4%BF%A1/"},{"name":"プロジェクト管理","slug":"プロジェクト管理","link":"/categories/%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E7%AE%A1%E7%90%86/"},{"name":"開発プロセスモデル","slug":"開発プロセスモデル","link":"/categories/%E9%96%8B%E7%99%BA%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%83%A2%E3%83%87%E3%83%AB/"}],"pages":[{"title":"","text":"google-site-verification: google336114c45a30c979.html","link":"/google336114c45a30c979.html"},{"title":"Contact","text":"お問い合わせ 案件のご紹介をいただける企業様、AWSや開発関連のお仕事を依頼されたい企業様、ぜひお気軽にご連絡をいただけますと幸いです。 お名前* 会社名* メールアドレス* お問い合わせ詳細* 内容を確認する","link":"/Contact/index.html"},{"title":"開発実績","text":"1. 项目名称：电商网站 技术栈：React, Node.js, MongoDB 经验： 学会了如何使用 React 开发响应式的前端。 使用 Node.js 开发 RESTful API，并连接到 MongoDB 数据库。 在项目中解决了性能优化的问题，例如：利用缓存和异步加载技术提高页面加载速度。 2. 项目名称：社交媒体应用 技术栈：Vue.js, Firebase 经验： 学习了如何在 Vue.js 中实现双向数据绑定和组件化开发。 使用 Firebase 实现了用户身份验证和实时数据同步。 总结 在这些项目中，我深入了解了前后端开发流程，以及如何选择合适的技术栈来完成项目需求。 学习到了如何在团队中协作和分配任务，提升了项目管理和沟通能力。","link":"/Development/index.html"},{"title":"自己紹介","text":"c8d6a724b68e0a127e5cca7999ad3293188e6b6b77ec374bce2067daaee372b4cca38917ce33442ad7c7671baaebf3abccb870d3790609ee6842f2a1618b8549a9c6fb2c8af5ce7b6d482ec946cdcc5d7bea4676fb4a000a1ff22d9ff8151267830a3331b973aab0992226f7738187be534eebbe59c320a386fe988a528b3ce6558219ed73d3093c81993b7d21d789a05afc560f048f59b401ae8c264b85b256ff05edf5098bad043e1e1947c501a6c5e1352d99c4792d9d3a9a4adeb369937e989407c6d0228de26c92b8082d9d196638f46ae2479a1aaa5bfda246c9f9d6d0591d10be15403f750ef190d36e2b0ad17357101b66c71efb0d7036135ab43dfebd3aeb41a558a87fd412e724b1f4e75b7917358aaf107b8265989085595ce6e235eda7e5196ccea743c173acd7bbcbf5af60657bcc948cf3415d38e5c957bcb754fc79cc55ca5191fbb348f665555fdc0004e2905e4eb2e08da3157d0c8d122ea0039760e1fe5a859830484beda87a0ce88f57d0a65adaa2423f1ad0200a96cb03d9729d42ef09b9ad7364e25f4f8d79db2dd248e2fa96163b2e97253b7196f4af54897abba1afa6137901419795a0c0412ff6de6bc8b0d2b80abbbabeee6fade0a1a72a31a3090ea433178edd100944c372aa48b7c019691cc85aad7e16cde20a7e3645de684b04b0fc0bf0cc6e633e8a64e1e5966dcd21d15580bed19ccd75656cbbaaaf6d238b52828a3c96eac2aef918af0c63d48bdec05749f1776ddfff3cfee2eb4b61ea1a331e207f784609bdbef375617fbc2ab7e24c12f3a916b5bc8311e468ab55b239b8afc44d5734aea96a2f640e03e4fff0b5de6165302306a356607b027e8cffa8bb1ac21dfa30aa0ea1fe5b8a91cbac37efb533f4d25522b888048af5fce2c85ce67f8d08bd8d654eb581b1fba80c40a167ef44f3103b6237af22028210eb3faf3fa80daf281e543d335e575752389b07a51a6cd2e2452aed0163fa8749243a2e40fecfc986ea1f0f2a25a95a4109b1dbeebf5d64f1d7929482ebe178165c6d290ce912bf7ac4139464f7c416a089151576d4a808a7f5676da67a9a6c104f01b5cae23ab17e50f03a6fd005f7c1db693f91c8507188e28d015f403c4e00ab0fc08be2580cec914c7ff5303ec5893905750334fbe2fa15328ea1d38467708754008c9e1d148c14e7e5625b0fe79db59424655c1f096dead721e5a6f097c926253867c97fb560b9ffe4eafaf712f3e9c3f159ab160129392622b94909e710e496a7f2b61e6d4a3a8a4f92b7efbac93b1958a813cc29f0dee15d63382b5e601f118510a124d74211414cabde10555465a8fafde1afb5c78d399cdeab0c573b96fdc19ccea06ea371ef9196c0d06427e2ac31ab799a29f865d8db15d341ba6f1bac8ca1ed55c03c6fcc4b81e989bfccd6d63017bebd8b56039cc03b1a22c07f2cc13c141468edfad2c78d47cf2786a9fc46968dc16d7c7a2d0f971610eaffee4a02a4464dde4f63aabf0afb31667c56de0238e0eb8d4eba6b3bd0a4f38490eed66d146c89c424a4cb1e5f43721c27a7b8c4ed83730a1fe5cdb6aaac41d376b74f9e1afb270b1bcb9cccc4c449ec50a22d4a2a0b57bbea76a734d90d4b017fe66f0680431af9dddc7d6edda4a90f22528d92b779bcffa6c6bf112df5b4b27fbb608b89d46019a67699e656ab52766098b9d332cdaea597178227596e507ea0acad0341e45675b4a08e2742be59e2868999453e7e5d3bdce95ac442d4cc537593c8308b9f7a0e6d61143ee0cce61acc0ef1230bdac2a5d5fee396943a29719d8af9bb3232116aed31c44fea2ff32e6de87ba9eddbe626916fbc68c654cab2c3b7677d621138ba822bacfd6d4298e1debace31e170736263a55627e78fc78ac32f40c5c6a2feeafc4a99dc47b6f629644289e109f78e62a1587c574dc62c10494bcac3d8137a6197bbec78900a5a73e49437524830acdb462a004a0f5b2e98a6a15b1db2cd3def78a976081458dcec19d9e6f09d74fa93413b2a81eb837c3df04a811a7825ce1a2b6666b3dbb525b77b868d6d0ee3773af3a9fd471179fdc113eae567fc8462654f314b93c95db7ec5edc8a56f0ca03bab2884b2e360ca9315fc943166a0f33400b5f3aed6591da4db48ef4059fbc31ee4bcaf77cfd4348539692cf5df3d0305f18b937ca3fa3a398147b8caa805535a80291af72623f01fd44ccacfc464cf9b5e03e6771d64ec24c212f2c18bf9982bb34d2d4a0eb102c65b8ce9a0eaf7d3ba837a2fab70beecadd64ae9e7a4b3d0abd1760f9b5af61bd9801ea2698c954bc04553334815091717d971ad1bc1e7c2366c71a83f00b7fb5c89b4eac7b2b42d0c6187151c1ad588d3732c91ff7e794acadfd6969f221c32e5d9c95c674e60672c1fd9dcd3c5386815260c8767727d8bd5855cbca5512a25135dc6751f707f35f998c9bec35c470c37802fe85b424be8a249c64b0e90a7c42fe9507ac5c61ca1a55f5711535fb1d59b5579533fe6c7ec89a6385d397aafb78df9a43c508ea04741a48240f72e64ba41b61e137c8ddc47a0ff8901215722505e8229b4f5b57ce60b69fa9cd3cdd8354e02ce2cb50be70af22e08e2c4b724379635e8c5c8f3e2e405e544bbf246dc414965e583e311673199f10f3560d8f3763951a78f4644e49e31e416895efebd0ccf2699d12200c891c344618b77ae86874e1b110a76cdb1225ea02ef8387d4a90d80e110d5a75ea1410d539e5f4f102fd8d76487e734b29ab59f0100edaa736e49a111ebdb137c7872e5624698051874dc839896ff99d4b5f9fc95e6b225501de1dfa39d77e455c2186f6945328d437d17cfb22792a9a6ec0f41746467570611e112e4ee867a31067da7a4ec188bd702ed130983c54ee947dd74937f5ff1cfb1d1e272cfb8c7ec1eaed7fc71e19162e3594097799fab43b7077737940f8c58a4ca4935955a7d4572c994f1cc2af187aa49d364cd9a3c5ea05204496d641a7d35a0cd53b7d11e07d4c6251934dc3f5094915c755554aca3075694c04d93fab3380d19d52b6f8105f9d34366fcf9b498b4088bdee8090ccaf19c3a9c32d5f89730d9169206fc6bc8c56ff703b16f97c0155d7310098ffc0508dfd8769cde7a0b74a4c27202851f26657cd7ab151639f00f8e64c968ab722460ccb78ae05fad1febe2ee3b9a7af2f91a27ebdec3d9ee362202df66b6fcf79a3fefa36677420d4eb7d191915882bfe181bc2b963793f9f74a51f183598ed3d3fb4ef94cbae27f846dfb3875116f16eda8cbb3166b5edab96658f612cd15980ef4b72c8b6277907d00b56a6063a9ec4a1d9ba4b1a0af025a4031015cd1dc270c2d8b91174c2aea3260b80384999fd6ab66110f8af3a61eef827fc2636567e6d90232ae1eb5815eb6fc416939b0f7ce8077541ad1a0d1729a078ad0348db4a58b904066cc2c4740d793d24764069d6d9c2730980d76d4450849e739fdbd6a9704d197c7588fd0070ab8500d013118dd4dfae670a1626e65d7a790d0afc72609a2abc6e662d947950673f87ff27320349ae85f0927330df0135514bba9d1aec4be42f4482f5cde0dc5f02126d0b50716100622419eab8060315c8a9e38df05eeb235a4d05cad1f8aca18a11dbd5c1a468c2ee75c5c31a0da131468d994e9d6f079eee2bee881e5b01a36f763191cd9a9766357e1a02490267604870de2f97a020658352912cb857a6f0e15fa878fe24cc752d49562f719654e91b3b285cc6af4b64948657dd77074cd844a25cc255af8e0f61299dd1f4a2f32bed3fd40c398f448c199b08061d59cfe40c5e24340b6052e90c79383eff146c5866c52c690b7e4a86d3eb795b67ac9ccfaac697906d796eccff4043170e0935e986d8d7430f221ddb5639998c951da973cabacdfdf89d83ced903f94606769081d57f1953b7005ac0e92c9e44d228c66c4c7e87e7163061f47d8e60c683a3894870b0ff94f5e746ac1fac59b6917ae2fbb5ea5cbda94d6473283ccb6e1f829c93448176b30483ba99c46eec36e5ba88b71890f735b1a7cc2c2dd6ad517d76aba99a75935885b1a121f1d035cafc89bb030c63f9122a60d3d2dc62384d9893d9a2cc663410493c0e652f3fd5bcb5fd9ca07a9f53718cae8ba93b7844cc0bcab2747115b71e6c3a6c2021fd208a2f7b6c704af836a4472f489bd3596b51957766440a6691cd26c7c62ca9942fd075680b47045f44cf5d83fc8ab50759103ee2f12356a899e2d50d490a540d2b095a99461c9ef442e8ee04e4b3a338a8a077321f6da4b35629b57ed6ea0e3732599e92482921116508541a8df4114490a4c92c12606d742c75e097121bb4e91479615a71d7811fde577c6a6bd7721a9a84cd6dd17d27f9bf2f65e5bf40cf346b2085b10655c3c7ac703fa36e7250561e8df5203b72a1bec147a684f3aed09f241d765a1fee67921f6416ec65484bc1646421136275b14c6f5cc9579cdd0bbf70d9022459559cc8332aacce34193ec99e9168e47c0bbfc2dfbaf2d44d4c8e72beb1e4d09b74f293e02e5d2a9b863250979abe31ddd8492066870c27d8b8256b78745dc87b373a693be0ce21acc716ef8cecaeb0d6128d6ca9cfa70bd9ee81dabda26427896afadd5f6b3408b1eca5f35488489e2e072c5305314a892642c24f3efe61c3a876644a0b11ca7639b4130d91cb069b7a9ba506cbf2ce2cd46eb9a4f332c2b592676f65f3041aec2159d1cd6ec5f830d96c1c523539a81911a70eed28a1f952010a1548b1c5c512264bba43c3d8f0f9fbb67dc3a0c507c1b9dd38ce15628139e8eca5b10095d9f6d19ad37958f1906a106defe9c0ea45f2f36c4d5cdb2229102527b0f2e10c2af46fa3b5103869c4d805894b37d04eb451b391264d4fab513804114b3b87bf4de2b72133777fe6ebcc8927afae81e59d892861b165336fdb892f25af9418c4fa61a97f53b70ce3755691877405d63f53f43de75e1f89c71f1ff15b5456ddfb7d6beb3a4a53657a4b558ab1e1447c7e88ffab9e2dcb18ebbbc6dd4868958b9990e8320c4a14c4a66cc29a493fa0238f5276617ba50f5b4d4e5c2e06816a24d6ada0a5e4708e24ec4898422ce78160bc8f15eedfda8cd0ebe28b79a97c9586e6e309e50d5a5e5e77182ebce48902034b6b2de643499e37489104a22e79f8601f5b9fa0b94f020ebf84d8b33d66f0b0aedcddcdfeba96bdf053d57c66e9c196f68033cd2675db831a4baa1130f1194e3276b8f4d93413923d7047ce377c002ba38a8e0b27e73a12c2886073971b05ce391178976c61fdf663a87b1ebd86038336c0d9cd06b2b552ec3dd010a88190e11c00ba60fb0306a14f7f057dd017a3bc282e19658fe599fe16730341273476aacde7190a16edc94cb74efe20c916a023d35bd3e2f7743141b62703ba5c23b15171529e7b9347a7b9ed985fb06157d741ff42a2aa4481f9bdbea022c98ad0c31ba802f39498a9cc8dbe4c4e09d8fa7576635a8c2e8b0188d1101af754d5347afe87d30dac580f325a37f88086876e79dffe03c77e6784ec9e1dd249e9a0511a86e92589ed2e96ee0eb806ea99604d160a4d551b3c9fc634d640e285d9163d3ba0bfd08008ded7a6a7c50da023d4971404e24248c464247c440bbf5928e4ecbf75a09f625baedd73801b0a86efad7d49792b27456e62b0d9594dd9dd1c9220a417ae36e7186c1ef013cfa9e35b7d8eb7a0497d128ac7cc660c7a659200311ac32274c1d737488ed8a9deb8737e63712482b401aa1fc9c14e06de76c579a25dd74c8566047bd01ab645aae09dba19e9b8c9a0deb96db1029c0deca6c5ad2406f5c686fe4568049b54da3e9eef679dc11f78a22384f2965ae36c058c3e85a8c847d19c919459628cc146e9e6a81785f59019eace604fab10d35efc20f4ff9077ae722c47c9752c937924654675ce6c90e78da9e339aba52ca9255aa5ae81750aef6580f77b825c6eded77b53793954ee88fc75bcb2961f43007f41c89a926d72dede3e368d66bc27768ce80a83c177b43e1a1dbe6e949985ef59e959a27c9a6e3e195f09f1d2550b5b7221ee2cd17b69b643d3a598b0261f2cd212e38790925a68ec15faa383143f2db7e45784ba835a25902d6e08b8b5c570b7fa973c37d6f8e096c6cd55ecb082f13ef050444b7f4fb9ecf2121e5b0de1107251dd7ed3017817e40f12dce342c9682be6ca440f378ec0f8261b1531afc34e4307dd8d2c80a66b2ed47e11449721d4b6c84c517657870e91e97cadddfd30d49eacd80199583ec34f8dbb8f1cd1bfe64be0a3b05caa522a635f5490d72f65b83cf284efdac05920cdc5df3b1e317697f0824879918714afb8cbea890beb1d998c1639aa614959812a02c2c078e5f88c8af1d21e226aa42a1ec5e3816c577d9876449a6af7d2befff1bd48037d509c61ba10b2670a8e9d6194fa96fd98b981652beed9fff2b35aebd2bf599acf14d6a959ea0baf9f0b9815e23e15e36d5c9c66b4fe9f34bc9508d0a17ff23ee463fea1305f6ded8b1a36e6cb332af4080287cc0020efdfb05cb45bb2c52a6fd576073c64b70341fb310c694bd90e81a82164db16dac30f282883546911772c6e2185e069879b96ba3811955a79265b59b4d8c5f87a36ef302bbb4385f3756a1bbb902d64b341310a1f548934134bcf8b28a2bc056a3756817e88f4ced7116a214f577345abed0b6d2947db1bbce61fa429963085ca46b070080791db3cd244b7e64016b2a6e485bed1e5d4dba0c4d9080f1a50e2bff238533fa9dde812bf0f74a48f4152787013e39bbc6945ecf3ce2eac306f54ae95eb7c3aac31877f6b2e94746d9fd3203b260593ee85622c5b0632c3f1598c2efd5ff3b56aff4048cd7eacbc604b460ec4f48eb96ac81e55bd41f54e5fa28ba0fec0bb6528d69bb4c16d2bb167eb8f37f1eeac261bba599a53f996574284b196c92503e515c2dff41b1259e44c4d7230fa8419e5168ac982b8f31a2d41684ac4ae6b0c3adc62a84cc3988e2948b1e34a38952c94ecde67738de6a9192cfdc26003766a2a77c421b66708cb9eae86f407e058ad5530fd4742d5d4523f89c7824cfe5ca21e5dbfd6306cc252d1937516dd629e774eebc5332ec27364adcfaa2e3dc7f8627796f2b16efd6f454c58805554a8821074000d07bb5ba91e809bdf5e6a8c5c3753e1574a7b001152dd589d2bf371e7ca8d45399c527d3de23bf320cb166d5581da623612d56ff91642c1ee7406e67b24fa607629f76c28fed92b95798ae1b74bc52285d12f1d151300a7d07ddf2bc84acbc9d04d84abc53a73c7e495050b464d40320480011b3aa1ec2a4a2347caae3a2150c339e46fac53916f21d196909e20ac0e45d3c081f939f46b7b0715141dc38c1581e06f977a640352ef0f8b83071e78c264af7b219f3c28aacf0cdcda87fe73b38b3a43d109f0645f36a618bfb8a1015c022e69eac725824849c7c9517c5cf7927d8a2da869a477c2bc1d029d6f27a776a42ba2982e88b82d343eb0449bb4e0605aa24cc55bb4ac466328221c14bfa2e46ea75c8191bbd2f50ad6689a73adec11480226f6d5d70ea45d656e6df7ad98a70d512cc7d7cd436760938f6191118397f7e6f2750c7477c48ff7c012c99a5de60da2d89e0ef401972e1428fee2f93747e866f06907a47343dc569d47c08bf736f16254cdcfe08c9ebcd9c406a08473dccc1b88905ccc9e37fefa562ac6579a5bcc6e36edc4574289e6c0654e2ea10d9287a2878e570e8f648dfbc5f684a54eb189d36b4df4b60b6cd7f8b3cc9ecb84d1a161a7342895391642602699aec9092057369ad6f65a48494f5fcb640e5a681f2c896c8fd37638a2adf8103c387f67f1df36bfc003a6b09df53340fdc385b4e9b3ebc9d4ea88d7080139dceee8fe6b6b70de8139da749052c2293975d8536a716699334f79f9933a97a4f2f202e8d8dc653c63fcadf578f8729e1f78ff8dd89d026f203166f3e3635e85485a6714cfb1d393292e99fcae640d5410acc6387b1b8d0c330b33164bcca01df1545ed216c10e130f1a1053589ebce22a52912b978b824e29ee9d3ce73014fac8f1cb210cfd149d8a9ed22f3f98f87f62cf7b871100925b505e3595d3387554ff2c2fca7a1ef2e7a6e4dee44eccbbe4f79d0fe87fb55c2d9d496330c1bedaf8f57dc97d3b1a5f8bb4ae8d0ffa80a6d65c3dc51f46f49a438ced0577836d3ee9e8b7aa443240262cdfd674ccba426e73a98feba18866ebf05c1bc2b5278f32cd369690690ee85c23f707eb466ec3f252121cf625bc9e36234716b0ccb00cbcfbad8a15d27168e16c0340d892ad01a0772208b5bd4b73137dd04c126a731fa690b5eeba047245fc327b0a9504a998e3f87987ccbdf2fc217afbcb66b8ccfa155aec52f198d964967d9b968886ae17c66985d8b5e74b11c248a308a5d0742acee04adde218194c7c0af64ff86acce5e6a14ba3d89bb94321cde4aeadb6f6bbecf57ae772b5905a0663854dce9be6efd1d20042e8211738ff3560a05b40fc86fab5d7a99d57d416f806f7a4fd1269e0f3a547d1c5592a8e88540972dbfc67c428f05392d37d073f14da2c4d550fd7ce3e51599908db1ef87c9d42a3ddb78df015bf82c213ab748ea0fc34f408b6fd28e1ed96f22ba709cef60a49088e61d94f77c1d475e08d6169796f1af3922fe972f668aaac47c80ab7f7c7969f0d989281691800bf4111e872d8dbd839f66cdfbec711347ef6998bf43da3dcb8d4cc1ebe5505c0b33c95aee7819adf95810449eaa05667b9869323cf87a295443e8d914d11352c99c1890a440eb090ea27dd6271bc5b95e93f957f218f6410fb1592c303052b8f5bd52b587e6b96bb4a28b6b62f77a5f72430a68ea96b485dd77f1bda662800ea97a76dbd75c43687a6d8e67e6ee331995d9de9533854ec86a27065363b78d51665066fdbd375db8f71e4504b19c904451550756f6ecd20292f63ff7b2817a927206d87d42705ea72afccf4d31673f9507f771798fa42e0026bfd143d6fa874ba3fc133bbec3a8ab22c83b20da62427aa3d4ef63f0ba8af9bc9793d5030cc631980fe0fab650bc0dc205a25b47b6cc2a744751882d4a85ebb8044923e8f3cda247cd1317be38d2c2f395fac613012e4971b49432c1a7ecff6922e8e0aed2ca599fee86bfa8c171b911e4c7fb84b32bb357410ae1d5944aea1cd1167309ccfc649886abfcf027d9c6d0ef45f541033c0154ac0e9b0f0084125a753189b19d069c41ee7f55fbef48fd2b287ca316f51048622b0fdca8a9ee68a7b603ee6e922d9e76775a6cfb2298bfd97a4f915a0afca839edae27aa3986ecbebaa8de63b5c44cc06dc1309df90314328e26c7881eb9c3a49f917582c6c42ce666896edf275ceac42aab45fd650f6330379d92b0d5b65e2047b2200ce49a01b605e4837db0a9bbc50ae227d454185db511ab7bb93798297233b264a4106ac4440ac9cbc49baf3f340ed5c1ca961da6c91cf921ca530ec656dd1f21f9aa982ee32c18c69857d1b5652f5127ca56afc241b7fe34129f89ea5817ac46195828168d68da419dcdddb94049165ea8062f4fb8a5d5748a587f5dd5eed57cb0db0d269338054564cb751049e679a958d0a8e618dce97c9381bff85a349d5931f952d7e28cd3034ce9fddc94f06ca089a6499d73758fa43310b90f78c8a4d0eee43407751a549d4ee868ce9fe010b4f13241315b04155ddd0e00b2804b206332bb108c3ce54bd5f129b5b2a0be4f8b893c806acd1d347bc261e5f797f4cc36ba52a83b666af179a07ba87bc42c05c7e2eaea2667d6dcb2218234c12096b1a14c77c1475066df70f02fb851cd3a1946838191f2248d87b9048b1d88d5fd837dabc3cb0dc4db369b02b47e0b361f4748adfc4cb18a397af8a7d14a8838a5da029ed819caa163e184b53d7accd2807ee49b4d9c01c3b1010b40d9ac24292c2ff7b46c581964cd949e81fdd979f88bd6cd1073defc87fdb43e5dfe3053e1e15bb04ae2dae9b469398465c24e0a6bfba5a345b2c114b322bc5634c8f934bf500c43d5bf9c75530bc770dc06ed22fb498511988de04ae85514d3e2e717867a20c547c7159433288ef7e2e0320aa1b34213eeb38f3448f9898f5f737272326fe951863b667836802002aacfb38905e3037a4e0fbf0b7059ac31242d116fc5542206e014fd20cb9d1e5958299d45d1081a819afad6e027e76eed1ef9db2f5820e822aa74d9bcc09c50ccdf2a61f28332a5b72cb5652bae4644715014166683999d417e3a5e002b568621d51dddc457e7aa23cd5eb971065c435224be03944132be6f2fa2307ada7b3fde4655001b8485bc2b37e3a872f4ecff529ba6090645447674f4f0437ebc17b18c5f4983ab2333fe08a2967519ec0780695eeaf62e9153cdbba1988869d0008af8239e4e66a200b67abdb8147fc0494ef5cf907212a495021975dc7fe70dec428422081dd1d8221713ca6a9bd2c49b56e6325d186c58e70a82a7f3f96630de00237626ce2b4acc0dc0706f1156f2b5008007c7fa8e9112fe6d04b2076452c0ca4c787206e43a2a0c87049065b0aba870941512c7632a3970bfc604fbfc44f0c233449a0a968be9f3d097ad026f6c9002115d9b9c95da5872e65b33bd0080eb8d1f7b36869fcc0fff9eae64f1ce4dfd1dea9bc3f8bd3051483835216a51b803b6bdbb5e21ce8f138efea5c0cf58f7639e65ca2f5393bb64131e026ffb11955743d93a57c0d5535ca4e4899477f903c506d274527868a8755bd40bf70e3409e92ee594681e292a567c2508df37a8ddd9e27d8d50792eaf45cce501c5c91a8b96b4b5e8424df37caa6ff32280a080c422c1dd21391c4103a6df91638365905218b1f777ffe8c9f71a4380a5e11f7faff436ff11fa3ab5371763806ffd9e3a57b97899cecf772bee19bf882df0056a322fdb18e2638d2f298e37b04037ddeb2f206aebc5218d580d92fffe792cf37920c718f2b2ed280856178cab6650280b9fc51190d22e0a17c67ce44afc2cd034d0d3d6a01055b552f89a0c9e55dadf4a04eddea501a5d6f618311fcc958d7bef0540d2edfdc615ccc7c7b82ac2d65756e92106b6d2e3c57d4991abddaca8229c9550b71a6200f56cc6715c59923eef0b5b8a72c5793fd6b679a0389b5c4878f44c633216ef14b7750d7598801f12257306c7f3bb2b164dfc1f3997581a5df24cd4466c0f63dfb2ce6b9b166730e55ecd0b250ad23a28880e37fdde762b1913abcef24b56582543189587dc5a692bc0b6600cd964a1bcecfc6cf5e22bd255f9ee71503eaa24b992dcd000d4eceb758d52ebec6710f83aa4476460237075134d06950e7558fe9e1e17688e5811abd26a09f18e443e57b3bba2df3d26f82403622c78076f1cda51c7e962204a5361bf9cda38f8c8e1508e5b66bbf844d5c04425b790eaa62ed95151da6a7ebc80272c652dee0cded67e583a36ebb426256bd0a3d8be458cc4b8aec539ba90d9ad8dc0dcf74beebc1164159170d64ad1411d67d403e45edd34771e3dc6a61d21be58fee19b606734e42e86a13f2cdf9d5a91377cc00cbbe73cd671859d45e6d89504214419e5197cc2dd97248c9657a11c5b73b6778395163bd291f409e9349e5a0bbb19e7f24ca58c9aac30abf63e3e6b7fefec7003d45d8ee4931c8890667fae16132e7e13e2f7ebf044b32cba7b763313ce0d42b38755935543124c7ed2f719306a9d4cbf7182d7519789c8c1339f2b81230306d75abe3f6da25e5fe926248b7ac22d65de3d306e714addd2502e1977576d09693b75adc43ac2216186da3f359ec8cbf274f2b4bd20210374a34396b56509b5ef5607132b019349b8a4d0294cb2ce6eb45b5a69b1492ef4db7353979fb8ad6d9cb2399df536103682e6fc937a606b275d7bb1537e17aa3677266e4a6e1cfed2bdd576085e21cf6663873dda8a56cf854e5b177f2a874306f3f1e15871289209657b7b8b3f0dd22d02d4e67f5d621c911140612e785fab19df2fb444efc096cb4e3547ec3941261903b6cf78d6025d7b387e1db5f657960530f5ab3998c12e848d62a4c9eaae130add0745e367552a61e9ac0711c44709c13a6de9e8a83bc207c8d66f8c871f788f3d3ebc29892bdc28df25b350fb8932a9a7ce6efb7f6a4e93a4b4860a57b6180235ecbd724b293bc29c60cfd49aed38369607c0d8662a771d67cd725ea22163758a2ba71f62c4696860cd9b7c3eb77620acac737648113f486b7153fb3e35dbce9a08692309d930545d3a9a625466d9b5525d5c102b6d1688eb0378ea14aa805e9a343bfd814278c12926e68efe6c43d698b47daee01039d3baf247cac5524a43c1bfb7c944e21677b16c88bfe6fbf825aa9aa0ea98ee95fdeb0f1011c4f06dc4524be8ab1673bc94910e9b454ed6a59a8ffdda50de0ae823271701b700c7f3a02418a9410db62cbadb18e7c680a4d145911b5182d3fbafb7254085f65c361406e47159550f32c8050845186dc1de85060126710d529a1d4f6c7d6db16d17bea7e219ae7572791d4c5e81555185cad812550793779439a4d8bb34490a2d3c85830f8436ef1bb9782d24a0ea5f960d83cb62928a96e7125637f1d305acc1c13cfd5896837248de30c62cefd86c98d62737b52656dd928ef5a16c40f9bb6f04cf08d2febfbebf2ba43a06149d4331edff7bda866eec60181b4e32f7870aabf354206ec4f2ec32fb6dd392be6938f424150069d6aea300d386c6f57f5993a059116b811e722d59ef788821410736bf922aa6efd09fd5e3c9be17fd39ca8e553f9038626eb07174d088a44be145d307b49cacb6c8572eaf58b9d4ea46fb2a316983f4dcd9810197a787b6b33f3d19fe699dd8018cc4eb25148e6bb9474dd6c8100b3f85ecd575945415ad20ee8bfcee828ddd041eb87594c6368a7406cdcc8788fd66382502f5b783d63d166065301f00d107ad6315bb831046126171c07550603b59643900df599d9590ef62f8496df1b258291738e8523fcf7a89856c22081a1c24d44e787e5ab133d168aa3858fb4b8eb0107562cee6f283081b26d4f17d3a7ba18f2c849f035549c3814767d88b30f138ef7b9819c40cd06c98e308bee62949ceddc511b6c8d1737413dbc5a08afd214eb10730e743160e3402b3d82a097ff6f85a2f45b73702ae3ab61c8bd5532a25b7212d9ecae188b6f9903fab0cae01d724f5a2d123c6e740267531546b711ffcd32e0024c4f92645a35542ae9ea53a87eb3eb46b35e466c2e4d3eec4775a1063730034d9fa9981d682ecf1b583321abd5227b2978e55401ed216c09aa6a3016e4c1ed8091b8a0ff9a5eecd108452e2023ed76bdb694850c5a535173e882b8705d18c2aa652120ab4e6acb2990a2fec98f1847d16380376ea7c258951fe444655dd9839b76e7f62bdef39251e3cb22413eb7089dc27418d3eea87f4bee6d295062e25a09e674b17d09823178a4d75d8a6174509fbe0eaf37e36d31dd9e11a6fd7fac1de26020b55a6e3f40678d135982ea1ba0fd98cf9e78c861b9d6d5b728d35325adc8c9b657b3fd1f735db1dc53395aa8082a5af7fb3c92bbae5b32fb27a27d9c3fbea3964b7fb0c683f41a85e9cd71cef55d0073b4c64027ed28d1f722b5da435007d250e59661d3f29aaaf84421159f467eab52d1972ce75a7b94985d963743514c1b2f1e96d11debad5ad92c1bf2af98958bbdaafc9583eb9a7f4ed1e6213b3d89e34917c7ff6dc6f2d3fed7be6c80cc146d2714c153105307b2560a8dd0df0fdf8c21b61d9297dc0893135263144f5110c22ab069419b159eb8fe48ba4eb70a5f38531e9c2b8ddd8e32b209e11097f2f5e82bc733617a9ae17b3b6121e9c78313b3bc499c7ffead98601a3ea5ed6ec9557a33a0bcf4d26486872618df6f24eb8e7fde68a327d4b8245be4ec71c512255c60857e6e276a4ade3a5762008474d50880b017b5c2e790b13b9af8513733d597f17b32cc438faf5b8bea7a11a9805eb89a9b847b34bd1ecfbda31eb27af6072a7ee002b96bffda3ba54cfc293d1a01b5d8dcf55e4add1fca04d5597a5ae3341e9a5dd86b2aebab729130bf53bc65d84820bf6bc3cc6415cd999f670fc6afea9f6c28fc802db99ccf0b7bc24b84d2fecbb0cbee6431a3ec8a8aeae23920284d61d6656218df1ce8a5a1c83ffb0e1fe1fd2d9dcd1924f8a2811b771319314e3582e39ed7d3a11ca6f426e42aa2477f10fe52b135172830744bc14c8427aed558cc44f2f278c09999425b79120f8346b60b76cd24cdbedec391df561d6d287804fae4f13c74ccfc3f5fe1e3102a79be9e8e66a2e8ee76fe66cb1cffe955c02e4570fee57fc1265e3b46ab90a555a83277ede5840cd914ffe5bf88105aa8176e33d09af5b970930d038043d85e4a61b25d5f0362fb3578baaeb549e2c0b456c873c3d5417cf3fe703c9d8c9b3fe3a223373108c8459bfb0bb4cbc26797329c5757ea6f6e29f7e4a4a6cd8c7034f506a68f36ce1ca7b780a652e2ee1a8f64fb2d082ba5e4efb0a2523d6106334ee1d6d87509e5678ad3370603fd59fb45275ba934c6e2f0e54f3af5784276048c6e7f633a743ebaeeded48123e985c3ebc067dbcce402b365cfd55a7861ba678557c868712d4e9c030bc7006fb4a2374e2aa5e308c598c917d0424dbd11d58b1a199c2333b4726933308e73a9a00388f7c3b76481e76cc3447e8ab18393194ebd3366584df2131b5b540cd99579d58595feb84fe3ae777a25ed56d4f584de78239dbf91dcbd6fb4e25a2bb1a359590b459d7b619c99c936f135336eeb91bc545e29bcf72175f4ba7de577652d7ee661d07211580e6ab729380197784f108dd5756f53fbc835882337e898cd74e3906675356b58d731aa2e64fee9ce1557efd5ba6f372400d0b9d631e77670d35bef960be3f853e3ea3f0212b26d20cbca10ac2bbf1bfeefb945cfef363bd5c7ded5bf46fcd048273750c79ce2e1f3a5c16beca7dc7281e49784617f465149ed32be7b2aebff4fc7094c688b91cf81f92ec75eaf14c3a3c8a7227dcae7ff7e76f5c2e461bd0673842ba81fbd307c8ff380879ed73994ba45cbe612acc65f3f56faba1e9f14b54df28a5581a596b6bdb1f861a90240c965454f2e766e38fec12ae44190f7bbd8fdc0593871be936aa9b4cd02a5f5091d7fd01d5e5a6f080686ca8ebe86454a792cc800136669cd47de05b708c6801c9e90e5c67d811e071c4e9921376b376134591856f5ca83272a4e17b706a5c3cdc1b9a5349fc0000b1b33ffd07b217aebb06e6e1e5ca11dff6ce549745ad3b623f8111e3016147ab8cd01299f347d688a58246958ac0a8a11cc52c3b0903db4206ff5f71337c1c6801843abc07cfa0553ee76e7d969f108ff82731444e0b02c70bc31ddf6bb6c7e8affbb979d20dc3242444055e0ed262d96d5b7fde11b94a0a882cdf415016bdba4529f015c78260b5f5cabfe1927b8f044bfe48fb2cee9b747880fc7a123f27f17b6dc24eb43068db2af16f21610d4595cd8a388227862ed7519e6a249c5036f597997612fbb6810a5b7f45fae98d4f1e52c85da1381a6d987d1c09f79653b7847c4ae4d691dd9dde0a14cbd8b6b3952a9d23469540adf652706b26c2dd0d2ecd7e0509a8e02ff54de123dcc1e32160e3712a4d08c2c5f0898597ea18b1f93a71cf1e603114cb0fb2dd16f17c8324c8fa16d8fb5095bdfa10d8670881f1c9c57b82f08e2adba8e7ebad49a0f4d64f85ad11710d8a7f68ece53ebc76f7195c0b0468fa6de22332e118a7aa3001d26312eb2df37b6a2929a98aea7f107ed04e0a75ff84cde61cde2d548e89b4639634d99983efc538969f56764f1df90df9723d89a260d80801a1c4ebc0ab715d5292640cb65847dd7b8131edc9d9628210b82f619f257329635e60a1f33468194abf9ed8779c348d840ed37111e16e5a9793547f2ac9aac07daa15af80492a013b372c3d0e01efeef2775746465c5462e0472030f78ff506e1e82b4a0367690e879af19c8362a0a7c00ca5da777d6a70269abda2ea5376131f17876ff9923743bc41d588a0fc61fa19bd5555cd76d3f4dfacbf6714540144873f08a2ebc2c554c709914360f44ad6dd3ef6b4af42509ce60083397e004d06096227c921404efc40a440b589bd1bf80f763bb216aa71aecfe771b54d7bc1323f0fd8428d26b6667eef5fb5459817eaac3212a9fd12d4290f7f40a6ff9922388fc785e6a518d3462199d34ea911eefc73a68423efb0a248988d514ef8e5b825623be85eaf6aa41b3771b0f39d70f25c23c17cf21b983bba44999cf75770b6717da4a57fa76c09d04316043e こんにちは、ここではパスワードが必要です。","link":"/about/index.html"}]}