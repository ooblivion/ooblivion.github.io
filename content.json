{"posts":[{"title":"AWSラーニングノート","text":"aws関連のチュートリアルや公式サイトを見てより良いですが、インターネットの残りの部分はあまりにも断片的ですが、公式サイトのホワイトペーパーは、英語の多くは、唯一の勉強に多くの時間を費やすことができます。 本記事について AWSとは何か、その具体的サービスの紹介 AWS（Amazon Web Services）は、Amazonが提供するクラウドコンピューティングプラットフォームであり、個人、企業、および組織にさまざまなクラウドサービスを提供しています。AWSのサービスは、グローバルに配置されたデータセンターネットワークを基盤にしており、顧客は必要なサービスを柔軟に利用することができます。これにより、従来のインフラ構築や管理の複雑さとコストを回避することができます。 AWSは、コンピューティング、ストレージ、データベース、機械学習、インターネット・オブ・シングス（IoT）、セキュリティ、ネットワーキング、開発ツールなど、さまざまな領域で多様なサービスを提供しています。以下は、主なAWSのサービスの一部です： コンピューティングサービス Elastic Compute Cloud（EC2）：可変長の仮想サーバーインスタンスを提供し、必要に応じて計算リソースを拡張または縮小できます。 AWS Lambda：サーバーレスコンピューティングサービスで、サーバーの管理なしにコードを実行し、実際の実行時間に応じて課金されます。 ストレージサービス Simple Storage Service（S3）：高度にスケーラブルで耐久性のあるオブジェクトストレージサービスで、画像、動画、文書などあらゆるデータを保存・取得できます。大量のデータの格納やバックアップに適しています。 Elastic Block Store（EBS）：EC2インスタンスに永続的なブロックレベルのストレージを提供し、データベース、アプリケーション、およびオペレーティングシステムに使用されます。 データベースサービス Amazon Relational Database Service（RDS）：リレーショナルデータベースの簡単なセットアップと管理を提供します。MySQL、PostgreSQL、Microsoft SQL Serverなど、複数のリレーショナルデータベースをサポートしています。RDSはデータベースのセットアップと管理を簡素化し、高可用性と自動バックアップを提供します。 Amazon DynamoDB：全管理型のNoSQLデータベースサービスで、高度にスケーラブルで低遅延のパフォーマンスを提供します。 ネットワーキングサービス Virtual Private Cloud（VPC）：AWS内でカスタム仮想ネットワーク環境を作成し、アプリケーションリソースを隔離・保護する機能を提供します。 Elastic Load Balancing（ELB）：負荷分散サービスで、トラフィックを複数のEC2インスタンスに自動的に分散し、アプリケーションの信頼性とスケーラビリティを向上させます。 コンテンツ配信サービス Amazon CloudFrontは、高速でセキュアなコンテンツ配信ネットワークを提供します。 インターネットオブシングス（IoT）サービス： AWS IoT Core：大量の物联网デバイスとの接続、管理、データ収集をサポートする包括的なサービスです。IoTデバイスの接続、管理、およびデータ収集を実現します。大規模な物联网デバイスからのデータの接続、管理、収集をサポートする包括的な物联网サービスです。 セキュリティサービス AWS Identity and Access Management（IAM）：ユーザー、グループ、および権限の管理に使用され、AWSリソースへのアクセスを制御します。 AWS Key Management Service（KMS）：暗号化キーの作成と管理を支援し、データの安全な保管と転送を確保します。 機械学習サービス Amazon Machine Learning（Amazon ML）やAmazon SageMakerなど、機械学習モデルの構築と展開をサポートします。 人工智能サービス Amazon Polly：テキストを音声に変換するサービスで、自然な音声を提供します。 Amazon Rekognition：画像とビデオの分析サービスで、オブジェクト、シーン、および顔を認識・分析します。 これらのサービスは、AWSの一部であり、さまざまなビジネスニーズに合わせて使用できる多様なサービスが提供されています。AWSの利用により、ユーザーは高度にスケーラブルなアプリケーションを迅速に構築し、運用コストを削減し、イノベーションとビジネスの発展に集中できるようになります。","link":"/aws-learning-note/"},{"title":"CI&#x2F;CD ハンズオン","text":"本記事についてはじめに","link":"/cicd-handson/"},{"title":"HexoのIcarusテーマを使ってブログを構築","text":"はじめに 私は自分が記憶力があまり良くないことを知っていますので、何かを書いて記録するのが好きです。 これは一種の知識の復習とも言えます。 チャンスは、心の準備のできている人のところにやってくる。 TODO 让博客阅读页面更宽 双语切换按钮追加 添加一个可以隐藏右边栏目的按钮，点击之后只显示文章，可以更加专注阅读 如何无缝切换到其他设备编写博客 文章页面隐藏个人信息 如何禁止复制页面中的文本 音乐播放插件 seo搜索引擎优化 ok blogについて 本を読む記事 Amazon web service業務システム設計移行ガイド AWS認定 クラウドプラクティショナー 项目 设计 开发 上线 部署的流程记录 项目中用过的开发工具和相关软件和使用方法速记 細かい設定 渲染器升级 将自带的 hexo-renderer-marked 更换为功能更加强大，渲染速度更快的 hexo-renderer-markdown-it 渲染器 【Hexo】选择更高级的Markdown渲染器 添加图床，存储图片 jsDelivr CDN 对 Github 图床进行加速 图库目录设置 PostPic/Cover/ PostPic/Thunmail/ DailyLife/ Program/ Reading/ Anime/ Others/ 文章页面调整 主页以及文章页布局 文章样式 h1~h6 分享组件 评论插件 其他 图片插件 文章排版设置 text licenses hide 在个人页面头部加入 aritcle: ? licenses 标签和目录的写法 12345678910111213141516171819tags: - 123 - 456tags: [123, 456]多标签写法，这2种都是一样的效果，用哪个都可以，建议使用列表[]式，直观清晰。这是默认的写法，给文章添加一个分类。categories: 123这会将文章分类123/456子分类目录下。categories: [123, 456]这会将文章分类到123/456子分类目录下。categories: - 123 - 456多标签写法，文章被分类到123、456以及123的自分类789这3个分类下面，官方指定写法。categories: - [123] - [456] - [123, 789] プログラマーがブログを書くときにタグとカテゴリを柔軟に使用する方法 プログラマがブログを書くとき、タグとカテゴリを使用すると、読者が興味深いコンテンツをより迅速に見つけられるようになり、非常に便利です。以下にいくつかの提案を示します。 タグを使用する: 各ブログ投稿を、投稿コンテンツのキーワードまたはトピックである関連タグに関連付けます。 タグは簡潔かつ関連性を保ち、あまり多くのタグを使用しないでください。通常、記事ごとに 2 ～ 5 個のタグが適切です。 タグには技術用語、プログラミング言語、フレームワーク名、質問の種類などを使用できるため、読者は興味やニーズに基づいてフィルタリングできます。 カテゴリを使用する: ブログ投稿をトピックまたはコンテンツごとに分類し、各カテゴリが関連する投稿のグループを表します。 カテゴリには、技術分野、プロジェクトの種類、プログラミング言語、アプリケーション シナリオなどが含まれます。分類構造は、ブログの内容と読者のニーズに応じて設計されます。 読者の閲覧とナビゲーションを容易にするために、カテゴリの過度の細分化を避け、カテゴリの階層を明確に保ちます。 柔軟な使用: ブログを書くときは、記事の内容を説明する適切なタグとカテゴリを選択し、必要に応じて新しいタグとカテゴリを追加します。 タグとカテゴリは、読者のフィードバックや閲覧状況に基づいて調整および最適化され、読者の興味やニーズにより沿ったものにすることができます。 タグ クラウドまたはカテゴリ ナビゲーションを使用してタグとカテゴリを読者に表示し、読者が興味のあるコンテンツをすぐに見つけられるようにすることができます。 一貫性を維持する: 同じタグとカテゴリの命名規則を使用して、ブログ全体でタグとカテゴリの一貫性を保ちます。 複数の作成者またはチーム メンバーがブログを共同執筆する場合、統一されたタグとカテゴリの管理戦略を開発して、ブログ全体の一貫性と標準化を確保できます。 プログラマがブログのコンテンツを整理し、管理し、読者の読書体験を向上させるために、タグとカテゴリを柔軟に活用することが重要です。これにより、興味のあるコンテンツを簡単に見つけられ、技術的なトピックの理解と応用を深めることができます。具体的な記事の内容やテーマに応じて、適切なカテゴリーやタグを柔軟に選択し、読者が興味のある情報にすぐにアクセスできるようにします。同時に、タグとカテゴリの一貫性を保ち、標準化することは、ブログの読みやすさと検索性の向上に役立ちます。 中国語12345678910111213141516写博客时，使用 tags（标签）和 category（分类）是非常有用的，可以更快速地找到感兴趣的内容。1. 使用 Tags： - 将每篇博客文章与相关的标签关联起来，这些标签应该是文章内容的关键词或主题。 - 保持标签的简洁和相关性，不要使用太多的标签，一般每篇文章使用 2 到 5 个标签比较合适。 - 标签可以是技术术语、编程语言、框架名称、问题类型等，以便读者可以根据自己的兴趣和需求进行筛选。2. 使用 Category： - 将博客文章按照主题或内容进行分类，每个分类代表一组相关的文章。 - 分类可以是技术领域、项目类型、编程语言、应用场景等，根据博客的内容和读者的需求来设计分类结构。 - 避免过度细分分类，保持分类的层次结构清晰，方便读者浏览和导航。3. 灵活运用： - 在撰写博客时，选择适当的标签和分类来描述文章内容，并根据需要添加新的标签和分类。 - 可以根据读者的反馈和浏览情况来调整和优化标签和分类，使其更符合读者的兴趣和需求。 - 可以使用标签云或分类导航等方式将标签和分类展示给读者，方便他们快速找到感兴趣的内容。4. 一貫性を維持する: - 在整个博客中保持标签和分类的一致性，使用相同的标签和分类命名规范。 - 如果有多个作者或团队成员共同撰写博客，可以制定统一的标签和分类管理策略，确保博客整体的一致性和规范性。 サンプル Category: テクノロジー バックエンド/フロントエンド/インフラ/設計/基礎学習 ライフスタイル 思い/ジャーナル/日本語学習/日本の生活/ 作業 仕事ノート/勉強ノート/試験の準備/日本の生活/趣味/ その他 ランダムな考え/サイクリング/歌詞/ &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt; front &lt;/td&gt; &lt;td&gt; JavaScript/React/Vue/CSS/HTML/BootStrap/Jquery/Postman/Swagger &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; backend &lt;/td&gt; &lt;td&gt; Java/Kotlin/Spring/RubyOnRails/MVC/BFF/Node.js/JUnit5/Mockito &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; db &lt;/td&gt; &lt;td&gt; Oracle/MySQL/MongoDB/PostgreSQL/Redis/DB/SQL &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; cloud&amp;infra &lt;/td&gt; &lt;td&gt; Docker/AWS/Azure/Kubernetes/CI-CD/Infra &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; others &lt;/td&gt; &lt;td&gt; FrontEnd/BackEnd/Music/Cycling/Hexo/MarkDown/Git/振り返り/筋トレ/雑記/EN/JP/CN/TOEIC/試験メモ/読書メモ/JLPT/作業メモ/開発メモ/勉強メモ/日本語メモ/英語メモ/エンジニア知識/単語/Linux/Mac/Win/Eclipse/Maven/IDEA/クイックチェック/work/外国人 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; Waterfall-model &lt;/td&gt; &lt;td&gt; 要件定義/基本設計/詳細設計/実装/テスト/リリース &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/tr&gt; backend Java/Kotlin/Spring/RubyOnRails/MVC/BFF/Node.js/JUnit5/Mockito db Oracle/MySQL/MongoDB/PostgreSQL/Redis/DB/SQL cloud&infra Docker/AWS/Azure/Kubernetes/CI-CD/Infra others FrontEnd/BackEnd/Music/Cycling/Hexo/MarkDown/Git/振り返り/筋トレ/雑記/EN/JP/CN/TOEIC/試験メモ/読書メモ/JLPT/作業メモ/開発メモ/勉強メモ/日本語メモ/英語メモ/エンジニア知識/単語/Linux/Mac/Win/Eclipse/Maven/IDEA/クイックチェック Waterfall-model 要件定義/基本設計/詳細設計/実装/テスト/リリース front JavaScript/React/Vue/CSS/HTML/BootStrap/Jquery/Postman/Swagger backend Java/Kotlin/Spring/RubyOnRails/MVC/BFF/Node.js/JUnit5/Mockito db Oracle/MySQL/MongoDB/PostgreSQL/Redis/DB/SQL cloud&infra Docker/AWS/Azure/Kubernetes/CI-CD/Infra others FrontEnd/BackEnd/Music/Cycling/Hexo/MarkDown/Git/振り返り/筋トレ/雑記/EN/JP/CN/TOEIC/試験メモ/読書メモ/JLPT/作業メモ/開発メモ/勉強メモ/日本語メモ/英語メモ/エンジニア知識/単語/Linux/Mac/Win/Eclipse/Maven/IDEA/クイックチェック/work/外国人 Waterfall-model 要件定義/基本設計/詳細設計/実装/テスト/リリース マークダウン Markdown 基礎 名称 描述 语法 示例 markdown-it-abbr 注释 *[HTML]: 超文本标记语言 *[HTML]: 超文本标记语言 markdown-it-emoji 表情 :) 😃 markdown-it-footnote 脚注 参考文献[^1] 参考文献[^1] markdown-it-ins 下划线 ++下划线++ 下划线 markdown-it-mark 突出显示 ==标记== 标记 markdown-it-sub 下标 H~2~O H2O markdown-it-sup 上标 X^2^ X2 markdown-it-checkbox 复选框 未选：- [ ]选中：- [x] - [] 未选选中 ハイレベル markdown-it-imsize：自定义图片宽高。 ![test](https://raw.githubusercontent.com/ooblivion/PicGo-repository/master/Others/202404042208048.jpg =100x200) 出力 markdown-it-expandable：折叠/展开内容。 123+++ **点击折叠** 这是被隐藏的内容 +++ &nbsp;点击折叠这是被隐藏的内容 title code","link":"/hexo-create-blog/"},{"title":"SQL最適化のヒント","text":"– JP –– CN –SQL优化方面的一些技巧和方法SQLの最適化に関するいくつかのヒントとトリック。 介绍SQL 优化在提升系统性能中是：成本最低和优化效果最明显的途径。 如果你的团队在 SQL 优化这方面做得很优秀，对你们整个大型系统可用性方面无疑是一个质的跨越。 优化成本：硬件&gt;系统配置&gt;数据库表结构&gt;SQL 及索引。 优化效果：硬件&lt;系统配置&lt;数据库表结构 SQL优化原则首先，对于MySQL层优化我一般遵从五个原则： 减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘 IO。返回更少的数据：只返回需要的字段和数据分页处理，减少磁盘 IO 及网络 IO。减少交互次数：批量 DML 操作，函数存储等减少数据连接次数。减少服务器 CPU 开销：尽量减少数据库排序操作以及全表查询，减少 CPU 内存占用。利用更多资源：使用表分区，可以增加并行操作，更大限度利用 CPU 资源。总结到 SQL 优化中，就如下三点： 最大化利用索引。尽可能避免全表扫描。减少无效数据的查询。理解 SQL 优化原理 ，首先要搞清楚 SQL 执行顺序。 SELECT 语句，语法顺序如下： SELECT DISTINCT FROM JOIN ON WHERE GROUP BY HAVING ORDER BY 10.LIMIT SELECT 语句，执行顺序如下： 12345678910111213141516171819202122FROM &lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。 ON &lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选 JOIN &lt;join, left join, right join...&gt; &lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中 WHERE &lt;where条件&gt; # 对上述虚表进行筛选 GROUP BY &lt;分组条件&gt; # 分组 &lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的 HAVING &lt;分组筛选&gt; # 对分组后的结果进行聚合筛选 SELECT &lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外 DISTINCT # 数据除重 ORDER BY &lt;排序条件&gt; # 排序 LIMIT &lt;行数限制&gt; 以下 SQL 优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准，以免画蛇添足。 避免不走索引的场景 ①尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描 如下： SELECT * FROM t WHERE username LIKE ‘%陈%’ 优化方式：尽量在字段后面使用模糊查询。 如下： SELECT * FROM t WHERE username LIKE ‘陈%’ 如果需求是要在前面使用模糊查询： 使用 MySQL 内置函数 INSTR(str，substr)来匹配，作用类似于 Java 中的 indexOf()，查询字符串出现的角标位置。使用 FullText 全文索引，用 match against 检索。数据量较大的情况，建议引用 ElasticSearch、Solr，亿级数据量检索速度秒级。当表数据量较少(几千条儿那种)，别整花里胡哨的，直接用 like ‘%xx%’。②尽量避免使用 in 和 not in，会导致引擎走全表扫描 如下： SELECT * FROM t WHERE id IN (2,3) 优化方式：如果是连续数值，可以用 between 代替。 如下： SELECT * FROM t WHERE id BETWEEN 2 AND 3 如果是子查询，可以用 exists 代替。 如下： – 不走索引select * from A where A.id in (select id from B);– 走索引select * from A where exists (select * from B where B.id = A.id); ③尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描 如下： SELECT * FROM t WHERE id = 1 OR id = 3 优化方式：可以用 union 代替 or。 如下： SELECT * FROM t WHERE id = 1 UNIONSELECT * FROM t WHERE id = 3 ④尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描 如下： SELECT * FROM t WHERE score IS NULL优化方式：可以给字段添加默认值 0，对 0 值进行判断。 如下： SELECT * FROM t WHERE score = 0 ⑤尽量避免在 where 条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描 可以将表达式、函数操作移动到等号右侧，如下： – 全表扫描SELECT * FROM T WHERE score/10 = 9– 走索引SELECT * FROM T WHERE score = 10*9 ⑥当数据量大时，避免使用 where 1=1 的条件 通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。 如下： SELECT username, age, sex FROM T WHERE 1=1 优化方式：用代码拼装 SQL 时进行判断，没 where 条件就去掉 where，有 where 条件就加 and。 ⑦查询条件不能用 &lt;&gt; 或者 != 使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。 如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。 ⑧where 条件仅包含复合索引非前置列 如下：复合(联合)索引包含 key_part1，key_part2，key_part3 三列，但 SQL 语句没有包含索引前置列”key_part1”，按照 MySQL 联合索引的最左匹配原则，不会走联合索引。 select col1 from table where key_part2=1 and key_part3=2 ⑨隐式类型转换造成不使用索引 如下 SQL 语句由于索引对列类型为 varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。 select col1 from table where col_varchar=123; ⑩order by 条件要与 where 中条件一致，否则 order by 不会利用索引进行排序 如下： – 不走age索引SELECT * FROM t order by age; – 走age索引SELECT * FROM t where age &gt; 0 order by age; 对于上面的语句，数据库的处理顺序是： 第一步：根据 where 条件和统计信息生成执行计划，得到数据。第二步：将得到的数据排序。当执行处理数据(order by)时，数据库会先查看第一步的执行计划，看 order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。第三步：返回排序后的数据。当 order by 中的字段出现在 where 条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。 这个结论不仅对 order by 有效，对其他需要排序的操作也有效。比如 group by 、union 、distinct 等。 ⑪正确使用 hint 优化语句 MySQL 中可以使用 hint 指定优化器在执行时选择或忽略特定的索引。 一般而言，处于版本变更带来的表结构索引变化，更建议避免使用 hint，而是通过 Analyze table 多收集统计信息。 但在特定场合下，指定 hint 可以排除其他索引干扰而指定更优的执行计划： USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)… IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) … FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为 Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) … 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。 如果我们知道如何选择索引，可以使用 FORCE INDEX 强制查询使用指定的索引。 例如： SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; SELECT 语句其他优化 ①避免出现 select * 首先，select * 操作在任何类型数据库中都不是一个好的 SQL 编写习惯。 使用 select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的 I/O，内存和 CPU 消耗。 建议提出业务实际需要的列数，将指定列名以取代 select *。具体详情见《为什么大家都说SELECT * 效率低》 ②避免出现不确定结果的函数 特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如 now()、rand()、sysdate()、current_user() 等不确定结果的函数很容易导致主库与从库相应的数据不一致。 另外不确定值的函数，产生的 SQL 语句无法利用 query cache。 ③多表关联查询时，小表在前，大表在后 在 MySQL 中，执行 from 后的表关联查询是从左往右执行的(Oracle 相反)，第一张表会涉及到全表扫描。 所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前 100 行就符合返回条件并 return 了。 例如：表 1 有 50 条数据，表 2 有 30 亿条数据;如果全表扫描表 2，你品，那就先去吃个饭再说吧是吧。 ④使用表的别名 当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。 ⑤用 where 字句替换 HAVING 字句 避免使用 HAVING 字句，因为 HAVING 只会在检索出所有记录之后才对结果集进行过滤，而 where 则是在聚合前刷选记录，如果能通过 where 字句限制记录的数目，那就能减少这方面的开销。 HAVING 中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在 where 字句中。 where 和 having 的区别：where 后面不能使用组函数。 ⑥调整 Where 字句中的连接顺序 MySQL 采用从左往右，自上而下的顺序解析 where 子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。 增删改 DML 语句优化 ①大批量插入数据 如果同时执行大量的插入，建议使用多个值的 INSERT 语句(方法二)。这比使用分开 INSERT 语句快(方法一)，一般情况下批量插入效率有几倍的差别。 方法一： insert into T values(1,2); insert into T values(1,3); insert into T values(1,4); 方法二： Insert into T values(1,2),(1,3),(1,4); 选择后一种方法的原因有三： 减少 SQL 语句解析的操作，MySQL 没有类似 Oracle 的 share pool，采用方法二，只需要解析一次就能进行数据的插入操作。在特定场景可以减少对 DB 连接次数。SQL 语句较短，可以减少网络传输的 IO。②适当使用 commit 适当使用 commit 可以释放事务占用的资源而减少消耗，commit 后能释放的资源如下： 事务占用的 undo 数据块。事务在 redo log 中记录的数据块。释放事务施加的，减少锁争用影响性能。特别是在需要使用 delete 删除大量数据的时候，必须分解删除量并定期 commit。③避免重复查询更新的数据 针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL 并不支持 PostgreSQL 那样的 UPDATE RETURNING 语法，在 MySQL 中可以通过变量实现。 例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么? 简单方法实现： Update t1 set time=now() where col1=1; Select time from t1 where id =1; 使用变量，可以重写为以下方式： Update t1 set time=now () where col1=1 and @now: = now (); Select @now; 前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当 t1 表数据量较大时，后者比前者快很多。 ④查询优先还是更新(insert、update、delete)优先 MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。 我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。 下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于 Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。 MySQL 的默认的调度策略可用总结如下： 写入操作优先于读取操作。对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略： LOW_PRIORITY 关键字应用于 DELETE、INSERT、LOAD DATA、REPLACE 和 UPDATE。HIGH_PRIORITY 关键字应用于 SELECT 和 INSERT 语句。DELAYED 关键字应用于 INSERT 和 REPLACE 语句。如果写入操作是一个 LOW_PRIORITY(低优先级)请求，那么系统就不会认为它的优先级高于读取操作。 在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。 只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY 写入操作永远被阻塞的情况。 SELECT 查询的 HIGH_PRIORITY(高优先级)关键字也类似。它允许 SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。 另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。 如果希望所有支持 LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates 选项来启动服务器。 通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个 INSERT 语句的影响。 查询条件优化 ①对于复杂的查询，可以使用中间临时表暂存数据 ②优化 group by 语句 默认情况下，MySQL 会对 GROUP BY 分组的所有值进行排序，如 “GROUP BY col1，col2，….;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 。 如果显式包括一个包含相同的列的 ORDER BY 子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。 因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL 禁止排序。 例如： SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ; ③优化 join 语句 MySQL 中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。 使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。 例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成： ELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo ) 如果使用连接(JOIN)..来完成这个查询工作，速度将会有所提升。 尤其是当 salesinfo 表中对 CustomerID 建有索引的话，性能将会更好，查询如下： SELECT col1 FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL连接(JOIN)..之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 ④优化 union 查询 MySQL 通过创建并填充临时表的方式来执行 union 查询。除非确实要消除重复的行，否则建议使用 union all。 原因在于如果没有 all 这个关键词，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。 高效： SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= ‘TEST’; 低效： SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= ‘TEST’; ⑤拆分复杂 SQL 为多个小 SQL，避免大事务 如下： 简单的 SQL 容易使用到 MySQL 的 QUERY CACHE。减少锁表时间特别是使用 MyISAM 存储引擎的表。可以使用多核 CPU。⑥使用 truncate 代替 delete 当删除全表中记录时，使用 delete 语句的操作会被记录到 undo 块中，删除记录也记录 binlog。 当确认需要删除全表时，会产生很大量的 binlog 并占用大量的 undo 数据块，此时既没有很好的效率也占用了大量的资源。 使用 truncate 替代，不会记录可恢复的信息，数据不能被恢复。也因此使用 truncate 操作有其极少的资源占用与极快的时间。另外，使用 truncate 可以回收表的水位，使自增字段值归零。 ⑦使用合理的分页方式以提高分页效率 使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。 案例 1： select * from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15; 上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销=索引 IO+索引全部记录结果对应的表数据 IO。 因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。 适用场景：当中间结果集很小(10000 行以下)或者查询条件复杂(指涉及多个不同查询字段或者多表连接)时适用。 案例 2： select t.* from (select id from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15) a, t where a.id = t.id; 上述例子必须满足 t 表主键是 id 列，且有覆盖索引 secondary key：(thread_id, deleted, gmt_create)。 通过先根据过滤条件利用覆盖索引取出主键 id 进行排序，再进行 join 操作取出其他字段。 数据访问开销=索引 IO+索引分页后结果(例子中是 15 行)对应的表数据 IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。 适用场景：当查询和排序字段(即 where 子句和 order by 子句涉及的字段)有对应覆盖索引时，且中间结果集很大的情况时适用。 建表优化 ①在表中建立索引，优先考虑 where、order by 使用到的字段。 ②尽量使用数字型字段(如性别，男：1 女：2)，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。 这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 ③查询数据量大的表 会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。 要查询 100000 到 100050 的数据，如下： SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,* FROM infoTab)t WHERE t.rowid &gt; 100000 AND t.rowid &lt;= 100050 ④用 varchar/nvarchar 代替 char/nchar。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值(NULL 也包含在内)，都是占用 100 个字符的空间的，如果是 varchar 这样的变长字段， null 不占用空间。","link":"/sql-optimization-tips/"},{"title":"Springでクロスドメインアクセスを実現する方法","text":"Spring でのクロスドメイン アクセスの問題を解決するには、さまざまな方法があります。以下に、いくつかの一般的な解決策と対応するコード例を示します。 @CrossOrigin アノテーションを使用しますSpring MVC コントローラー メソッドに @CrossOrigin アノテーションを追加すると、特定のオリジンがドメインを越えてメソッドにアクセスできるようになります。 12345678910111213import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class MyController { @CrossOrigin(origins = &quot;http://example.com&quot;) @GetMapping(&quot;/data&quot;) public String getData() { return &quot;Some data&quot;; }} WebMvcConfigurer を使用して構成しますSpring Boot では、WebMvcConfigurer インターフェイスを実装することで、クロスドメイン アクセスをグローバルに構成できます。 1234567891011121314151617import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/api/**&quot;) .allowedOrigins(&quot;http://example.com&quot;) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;) .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;) .allowCredentials(true) .maxAge(3600); }} フィルターフィルターを使用しますFilter フィルターを作成し、その中にクロスドメイン関連の応答ヘッダー情報を構成します。 12345678910111213141516171819202122import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class CorsFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletResponse httpResponse = (HttpServletResponse) response; HttpServletRequest httpRequest = (HttpServletRequest) request; httpResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://example.com&quot;); httpResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET,POST&quot;); httpResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;header1,header2&quot;); httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); httpResponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); chain.doFilter(request, response); }} 上記は、Spring でクロスドメイン アクセスの問題を解決するための一般的な方法をいくつか示していますが、どの方法を選択するかは、プロジェクトのニーズと設計によって異なります。","link":"/spring-cross-domain-achive/"},{"title":"基本設計記事","text":"基本設計について記事 基本設計 とは■基本設計要件定義のフェーズで作成された要件定義書をもとにして、システムの骨組みを設計する工程です。完成した基本設計書で実装が進められていくため、要件を満たしているか、また、システムがどのようなものであるかを考慮して設計していきます。 基本設計の工程では、以下の成果物を作成していきます。・画面遷移図・画面設計書・DB設計書・API設計書 ■DB とはDataBaseの略。データの基地(data + base)を意味します。 データを保管する貯蔵庫の役割を果たすもので、アプリケーションを利用するうえで必要となるデータの集まりを指します。 ■API とは「Application Programming Interface」の略。それぞれの単語の意味は以下の通りです。・Application(アプリケーション)：パソコンやスマホの中で動くソフト・Programming(プログラミング)：パソコンやスマホに実行させる指示を出す・Interface(インターフェース) ：接続部分や接触する箇所 それぞれの単語を組み合わせると、「アプリケーションとプログラムをつなぐもの」という意味になります。つまりAPIとは、いくつかのアプリケーションやソフトウェア同士が情報をやり取りする際に使用されるプログラミング上の窓口と理解しておくとよいでしょう。 ■APIの動作イメージAPI利用者が、事前に定められた形式に従って使いたい機能や情報をまとめてリクエスト（要求）します。それに対し、API側はリクエストを受け取ると、送信された条件を処理してレスポンス（応答）を返します。 リクエストの定められた形式については、APIサービスの提供者側が必要な情報をまとめて定義し、利用者に提示します。 面遷移図画面設計書API設計書DB設計書","link":"/base-design/"},{"title":"開発によく使われるツールやwebサイト","text":"随机生成时间 https://www.lddgo.net/string/random-date 平假名 片假名 http://www.hipenpal.com/tool/japanese-hiragana-to-katakana-converter-in-simplified-chinese.php 菜鸟工具 https://www.jyshare.com/ excel转html https://tableconvert.com/zh-cn/excel-to-html codesheet 工具汇总网站 https://github.com/rd2coding/Road2Coding?tab=readme-ov-file markdwon编写 Hexo博客的Markdown语法","link":"/development-usually-use-websites-and-tool/"},{"title":"自分でやりたいプロジェクト","text":"写一个全平台音乐播放器项目 用ReactNative写一个麻将项目，还有各种卡牌桌游游戏规则可以分享导出 雀魂----从入门到入土（内附日本麻将基础教程） 美食美景记录 地图 使用手册记录app 各种家电，以及游戏规则，组装，可以文字录入，也可拍照，AR识别 学会用wordpress写广告网站 写一个全平台的饭店软件（预约，菜单，）可以变成saas 写一个上班可以摸鱼的网页，这个网页可以暂时存储代码，可以上班的时候写自己外包项目的代码 写一个个人的博客，并且可以在其他电脑上登陆和更新博客内容，并新建博客 TODO 做一个自己的音乐播放器，因为我喜欢听歌，要省电，全平台，云同步，方便好用。匹配最新的安卓和苹果，支持热更新 练手，从前后端弄一个ECサート 重新整理一下的我博客，记录开发中遇到的各种问题。 midworks 类似的项目(自由职业者接项目的网站) 并且用rn写一写移动端，从api设计，到部署上线，以及后续的更新 并且支持多语言 技术栈 java spring react vue rn 如何部署到云 如何省钱 是否支持个人展示界面 有哪些值得学习的大型 React 开源项目？推荐10个React开源项目使用 springboot 和 react 开发的博客系统","link":"/todo-project/"},{"title":"仕事用日本語ノート","text":"本記事について はじめに 社内用語 申し出る表現と応答表現 (提供表达和响应表达) 何かお手伝いしましょうか? ありがとう、大丈夫です コビーをお取りしましょうか? ありがとう、だけどできますよ 私に何かできることがありますか? ありがとう、お願いします(ご親切謝します) 何かご用の場合は、遠慮なくお申し付けください ご親切ありがとう アドバイスを求める表現 (寻求建议的表达) お忙しいところすみませんが、少し質問がございます この件に関してどのように対処すべきか、ご存しですか? プレゼンの方法についてアドバイスが欲しいのですが. 予算の問題について何かアドバイスをいただければと思うのですが. 苦情を処理する方法についてアドバイスをいただけませんか? 良いアイデアが何か浮かんだら教えてください。 提案&amp;アドバイスの表現 (意见和建议的) 仕事に優先順位をつけることが大切です チェンさんと宜接お会いになることを提案します この帯ですと、タクシーよりも電車を使う方がよいでしょう 昨年の予算を見直すことを提案します 結論を箇条書きにした方がよいと思います 机のまわりを整理整頓した方がよいと思います それに関して謝罪した方がよいと思いますよ それに関しては議諭しない方がよいですよ Eメールの口調を変えたほうがよいでしょう それに不要になった秘書類はシュレッダーにかけてください IT単語 S","link":"/working-japanese-notes/"},{"title":"日本のIT職記録","text":"外国人として、日本に働いている。 日本職場のルール 外国人よく知らない常識 ビザについて 高度人材申請 引っ越し 引っ越しの手続き 転職について 役立つ税務知識 年金関して エンジニア交流会の話題","link":"/japan-it-working-memo/"},{"title":"日本語の句読点をざっとチェック","text":"本記事についてはじめに 記号 一般的な読み方 JIS X 0201 規格での名称 ASCII 規格での名称 ! びっくりマーク、エクスクラメーションマーク 感嘆符 Exclamation Mark ” ダブルクオート、二重引用符 引用符 Quotation Mark # シャープ、いげた 番号記号 Number Sign $ ドルマーク、ダラー ドル記号 Dollar Sign % パーセント パーセント Percent Sign &amp; アンパサンド、アンド アンパサンド Ampersand ‘ シングルクオート、一重引用符 アポストロフィー、アクサンテギュ Apostrophe ( 左(丸)かっこ、開き(丸)かっこ 左小かっこ Left Parenthesis ) 右(丸)かっこ、閉じ(丸)かっこ、こっか 右小かっこ Right Parenthesis * アスタリスク、星、スター アステリスク Asterisk + プラス(記号)、たす、プラ 正符号 Plus Sign , コンマ、カンマ コンマ、セディユ Comma - マイナス(記号)、ハイフン、ひく ハイフン、負符号 Hyphen-Minus . ドット、ピリオド、点、ぽち ピリオド Full Stop / スラッシュ、スラ、斜線 斜線 Solidus : コロン コロン Colon ; セミコロン セミコロン Semicolon &lt; 小なり(記号) 不等号(より小) Less-Than Sign = イコール、等号 等号 Equals Sign &gt; 大なり(記号) 不等号(より大) Greater-Than Sign ? はてなマーク、クエスチョンマーク 疑問符 Question Mark @ アットマーク 単価記号 Commercial At [ 左ブラケット、左鍵かっこ、左大かっこ 左大かっこ Left Square Bracket ¥ バックスラッシュ、バックスラ、逆スラッシュ Reverse Solidus ] 右ブラケット、右鍵かっこ、右大かっこ 右大かっこ Right Square Bracket ^ ハット、カレット、やま アクサンシルコンフレックス Circumflex Accent _ アンダースコア、下線、アンダーライン アンダライン Low Line ‘ バッククオート、逆クオート、逆引用符 アクサングラーブ Grave Accent { 左中かっこ、左ブレース、左カーリーブラケット 左中かっこ Left Curly Bracket | 縦棒、縦線 縦線 Vertical Line } 右中かっこ、右ブレース、右カーリーブラケット 右中かっこ Right Curly Bracket ~ チルダ、波線、にょろ Tilde JP 。 てん 句号 、 てんてん 逗号 ！ えっくすくらめーしょんまーく 感叹号 exclamation mark","link":"/japanese-punctuation-check/"},{"title":"バージョン管理ツール","text":"はじめに Git Gitを使うためのヒント SVN TFS 優れたコミットメッセージを書く方法 優れたコミットメッセージを書くことは、チームメンバーがコードの変更をよりよく理解し、追跡するのに役立つ良いプログラミングの実践です。以下は、優れたコミットメッセージを書くためのいくつかの提案です： 簡潔で要約的：コミットメッセージが変更の要点を明確に示し、冗長な説明を避け、できるだけ50文字以内に収めることを確認します。 不要なコメントを削除 Remove unnecessary comments 動詞と現在形を使用：コミットメッセージの冒頭に動詞を使用して、変更が何を行ったかを明確に表現します。現在形を使用することで、メッセージがより直接的で具体的になります。 機能の修正: ユーザーのログインバグを修正 Fix bug in user login functionality 変更内容の説明：コミットメッセージには、変更内容が明確に記述されており、どの機能、ファイル、モジュールなどが追加、変更、削除、修正されたかが含まれています。 ファイル構造の変更: 新しいフォルダ '画像' を追加&quot; Change file structure: Add new folder 'images' テーマの分離：コミットが複数の異なるテーマや変更に関連している場合は、できるだけそれらを独立したコミットに分割し、各コミットが1つのテーマに焦点を当てるようにします。これにより、コードレビューと変更の追跡が効率化されます。 機能の追加: ユーザー登録フォームのバリデーションを実装&quot; と &quot;ドキュメントの更新: ユーザー登録手順の追加 Add feature: Implement validation for user registration form&quot; and &quot;Update documentation: Add steps for user registration 問題やタスクへの参照：コミットが特定の問題やタスクを解決する場合は、関連する参照番号、リンク、またはキーワードをコミットメッセージに含めて、コミットを関連付けます。 バグ修正: issue #123 に関連するログインエラーの修正&quot; Fix bug: Resolve login error related to issue #123 絶対的な言葉の使用を避ける：コミットメッセージで「絶対に発生しない」や「完全に修正された」などの絶対的な言葉を避け、代わりに変更の影響や範囲を客観的に記述します。 機能の更新: メール送信機能の改善 Update feature: Improve email sending functionality 一貫したスタイルの維持：コミットメッセージで一貫したスタイルとフォーマットを維持し、チームメンバーが読みやすく理解しやすいようにします。タイトルと本文の区切りや最初の文字の大文字を使用するなど、いくつかの規則を定めることができます。 機能の追加: ユーザー登録ページのデザインを改善 Add feature: Enhance design of user registration page 小さくて頻繁なコミット：多くの変更を1つのコミットに累積するのではなく、小さくて頻繁なコミットを行います。これにより、コミット履歴が明確で追跡可能であり、後で戻ることができます。 バグ修正: ユーザーがログアウトできない問題の修正&quot; と &quot;機能の追加: ユーザーのプロフィール編集機能の追加 Fix bug: Resolve issue preventing users from logging out&quot; and &quot;Add feature: Implement user profile editing functionality バージョン管理ツールの他の機能の使用：Gitなどの一部のバージョン管理ツールには、コミットメッセージのテンプレート、関連する問題のリンク、自動化された操作などの追加機能があります。これらの機能を知り、利用して、コミットメッセージの品質と可読性を向上させます。 ドキュメントの更新: README.mdに新しいセクションを追加し、プロジェクトの概要を追記 Update documentation: Add new section to README.md and append project overview 最も重要なことは、コミットメッセージを書く際に常に後続の読者のニーズを考慮することです。これには、チームメンバーやメンテナー、将来のプロジェクト参加者が含まれます。明確で簡潔、具体的で一貫性のあるコミットメッセージは、コードの品質、チームの協力、プロジェクトの保守性を向上させるのに役立ちます。","link":"/version-control-toll/"},{"title":"面试&amp;自我介绍","text":"本記事について 日本語先生ボランティア When I was in college, I used my free time to study Japanese and computers In the second semester of my senior year, I started an internship at a Japanese subsidiary as a programmer When I first came to Japan, I couldn’t speak very well, and the elderly Japanese people around me taught me a lot, and I’m very grateful to them, so I also want to help foreigners who can’t speak Japanese very well, so that they can get used to life in Japan better! thats all, thankyou! 言語交換の自己紹介 英語 日本語","link":"/interview-and-self-introduction/"}],"tags":[{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"cloud","slug":"cloud","link":"/tags/cloud/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"back-end","slug":"back-end","link":"/tags/back-end/"},{"name":"設計","slug":"設計","link":"/tags/%E8%A8%AD%E8%A8%88/"},{"name":"work","slug":"work","link":"/tags/work/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"CN","slug":"CN","link":"/tags/CN/"},{"name":"JP","slug":"JP","link":"/tags/JP/"},{"name":"外国人","slug":"外国人","link":"/tags/%E5%A4%96%E5%9B%BD%E4%BA%BA/"}],"categories":[{"name":"作業","slug":"作業","link":"/categories/%E4%BD%9C%E6%A5%AD/"},{"name":"作業メモ","slug":"作業/作業メモ","link":"/categories/%E4%BD%9C%E6%A5%AD/%E4%BD%9C%E6%A5%AD%E3%83%A1%E3%83%A2/"}],"pages":[{"title":"","text":"google-site-verification: google336114c45a30c979.html","link":"/google336114c45a30c979.html"},{"title":"自己紹介","text":"","link":"/about/index.html"}]}